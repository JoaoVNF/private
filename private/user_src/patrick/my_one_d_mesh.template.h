#ifndef OOMPH_ONE_D_MESH_HEADER
#define OOMPH_ONE_D_MESH_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// oomph-lib headers
#include "line_mesh.h"
#include "refineable_line_mesh.h"

namespace oomph
{
 
 //====================================================================
 /// 1D mesh consisting of N one-dimensional elements from the 
 /// QElement family. 
 /// \f[ x \in [Xmin,Xmax] \f]
 /// The mesh has two boundaries:
 /// - Boundary 0 is at \f$x=Xmin\f$.
 /// - Boundary 1 is at \f$x=Xmax\f$.
 /// .
 /// There is one node on each of these boundaries.
 //====================================================================
 template <class ELEMENT>
  class OneDMesh : public virtual LineMeshBase
  {
   
   public:
   
   /// \short Constructor: Pass number of elements, n_element, length of
   /// domain, length, and pointer to timestepper (defaults to a Steady
   /// timestepper so we don't need to specify one in problems without
   /// time-dependence).
   OneDMesh(const unsigned &n_element, const double &length, 
            TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
    : Xmin(0.0), Xmax(length), N(n_element)
    {
     build_mesh(time_stepper_pt);
    }
   
   /// \short Constructor: Pass number of elements, n_element, minimum
   /// coordinate, xmin, maximum coordinate, xmax, and a pointer to a
   /// timestepper.
   OneDMesh(const unsigned &n_element, const double &xmin, const double &xmax,
            TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
    : Xmin(xmin), Xmax(xmax), N(n_element)
    {
     build_mesh(time_stepper_pt);
    }
   
   protected:
   
   /// Minimum coordinate
   double Xmin;
   
   /// Maximum coordinate
   double Xmax;
   
   /// Length of the domain
   double Length;
   
   /// Number of elements
   unsigned N;
   
   /// \short Generic mesh constuction routine, called by all constructors
   void build_mesh(TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
    {
     // Set the length of the domain
     Length = Xmax - Xmin;
     
     // Set the number of boundaries -- there are 2 boundaries in a 1D mesh
     set_nboundary(2);
     
     // Allocate storage for the pointers to the elements
     Element_pt.resize(N);
     
     // Allocate memory for the first element
     Element_pt[0] = new ELEMENT;
     
     // Read out the number of nodes in the element (the member function
     // nnode_1d() is implemented in QElement)
     const unsigned n_node
      = dynamic_cast<ELEMENT*>(finite_element_pt(0))->nnode_1d();
     
     // We can now allocate storage for the pointers to the nodes in the mesh
     Node_pt.resize(1+(n_node-1)*N);
     
     // Initialise the node counter
     unsigned node_count = 0;

     // Initialise the minimum x coordinate in the mesh
     const double xinit = Xmin;
     
     // Calculate the length of the element
     const double el_length = Length/double(N);
     
     // Allocate storage for the local coordinate in the element
     Vector<double> s_fraction;
     
     // If the number of elements is 1, the first element is also the 
     // last element
     if(N==1)
      {
       // Set the first node
       // ------------------

       // Allocate memory for the node, using the element's own construct_node
       // function -- only the element knows what type of nodes it needs!
       Node_pt[node_count]
        = finite_element_pt(0)->construct_boundary_node(0,time_stepper_pt);
       
       // Set the position of the node
       node_pt(node_count)->x(0) = xinit;
       
       // Add the node to the boundary 0
       add_boundary_node(0,Node_pt[node_count]);
       
       // Increment the counter for the nodes
       node_count++;
       
       // Now build central nodes (ignore last one which needs special
       // ------------------------------------------------------------
       // treatment because it's on the boundary)
       // ---------------------------------------
       for(unsigned jnod=1;jnod<(n_node-1);jnod++)
        {
         // Allocate memory for nodes, as before
         Node_pt[node_count]
          = finite_element_pt(0)->construct_node(jnod,time_stepper_pt);
         
         // Get the local coordinate of the node
         finite_element_pt(0)->local_fraction_of_node(jnod,s_fraction);
         
         //Set the position of the node (linear mapping)
         node_pt(node_count)->x(0) = xinit + el_length*s_fraction[0];
         
         //Increment the node counter
         node_count++;
        }
       
       // New final node
       // --------------
       
       // Allocate memory for the node, as before
       Node_pt[node_count] = finite_element_pt(0)
        ->construct_boundary_node(n_node-1,time_stepper_pt);
       
       // Set the position of the node
       node_pt(node_count)->x(0) = xinit + Length;
       
       // Add the node to the boundary 1
       add_boundary_node(1,Node_pt[node_count]);
       
       // Increment the node counter
       node_count++;
      }

     // Otherwise, i.e. if there is more than one element, build all elements
     else
      {
       // -------------
       // FIRST ELEMENT 
       // -------------
       
       // Set the first node
       // ------------------
       
       // Allocate memory for the node, using the element's own construct_node
       // function -- only the element knows what type of nodes it needs!
       Node_pt[node_count]
        = finite_element_pt(0)->construct_boundary_node(0,time_stepper_pt);
       
       // Set the position of the node
       node_pt(node_count)->x(0) = xinit;
       
       // Add the node to the boundary 0
       add_boundary_node(0,Node_pt[node_count]);
       
       //Increment the counter for the nodes
       node_count++;

       // Now build the other nodes in the first element
       // ----------------------------------------------
       
       // Loop over the other nodes in the first element
       for(unsigned jnod=1;jnod<n_node;jnod++)
        {
         // Allocate memory for the nodes
         Node_pt[node_count]
          = finite_element_pt(0)->construct_node(jnod,time_stepper_pt);
         
         // Get the local coordinate of the node
         finite_element_pt(0)->local_fraction_of_node(jnod,s_fraction);
         
         // Set the position of the node (linear mapping)
         node_pt(node_count)->x(0) = xinit + el_length*s_fraction[0];
         
         // Increment the node counter
         node_count++;
        }
       
       // ----------------
       // CENTRAL ELEMENTS
       // ----------------

       // Loop over central elements in mesh
       for(unsigned e=1;e<(N-1);e++)
        {
         // Allocate memory for the new element
         Element_pt[e] = new ELEMENT;
         
         // The first node is the same as the last node in the neighbouring
         // element on the left
         finite_element_pt(e)->node_pt(0)
          = finite_element_pt(e-1)->node_pt((n_node-1));
         
         // Loop over the remaining nodes in the element
         for(unsigned jnod=1;jnod<n_node;jnod++)
          {
           // Allocate memory for the nodes, as before
           Node_pt[node_count]
            = finite_element_pt(e)->construct_node(jnod,time_stepper_pt);
           
           // Get the local coordinate of the nodes
           finite_element_pt(e)->local_fraction_of_node(jnod,s_fraction);
           
           // Set the position of the node (linear mapping)
           node_pt(node_count)->x(0) = xinit + el_length*(e + s_fraction[0]);
           
           // Increment the node counter
           node_count++;
          }
        } // End of loop over central elements
       
       
       // FINAL ELEMENT
       //--------------
       
       // Allocate memory for element
       Element_pt[N-1] = new ELEMENT;
       
       // The first node is the same as the last node in the neighbouring
       // element on the left
       finite_element_pt(N-1)->node_pt(0)
        = finite_element_pt(N-2)->node_pt(n_node-1);
       
       // New central nodes (ignore last one which needs special treatment
       // because it's on the boundary)
       for(unsigned jnod=1;jnod<(n_node-1);jnod++)
        {
         // Allocate memory for nodes, as before
         Node_pt[node_count]
          = finite_element_pt(N-1)->construct_node(jnod,time_stepper_pt);
         
         // Get the local coordinate of the node
         finite_element_pt(N-1)->local_fraction_of_node(jnod,s_fraction);
         
         // Set the position of the node
         node_pt(node_count)->x(0) = xinit + el_length*(N-1 + s_fraction[0]);
         
         // Increment the node counter
         node_count++;
        }
       
       // New final node
       // --------------
       
       // Allocate memory for the node, as before
       Node_pt[node_count] = finite_element_pt(N-1)
        ->construct_boundary_node(n_node-1,time_stepper_pt);
       
       // Set the position of the node
       node_pt(node_count)->x(0) = xinit + Length;
       
       // Add the node to the boundary 1
       add_boundary_node(1,Node_pt[node_count]);
       
       // Increment the node counter
       node_count++;
      }
    }
   
   
  };
 
 
 
 //====================================================================
 /// Refineable version of the OneDMesh
 //====================================================================
 template <class ELEMENT>
  class RefineableOneDMesh : public virtual OneDMesh<ELEMENT>,  
                             public RefineableLineMesh<ELEMENT>
  {

   public:
   
   /// \short Constructor: Pass number of elements, n_element, length of
   /// domain, length, and pointer to timestepper (defaults to Steady)
   RefineableOneDMesh(const unsigned &n_element, const double &length,
                      TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
    : OneDMesh<ELEMENT>(n_element,length,time_stepper_pt)
    {
     // Nodal positions etc. were created in constructor for OneDMesh<...>
     // so only need to set up binary tree forest
     this->setup_binary_tree_forest();
    }
   
   /// \short Constructor that allows the specification of minimum and
   /// maximum values of x coordinates. Also pass pointer to timestepper
   /// (defaults to Steady).
   RefineableOneDMesh(const unsigned &n_element,
                      const double &xmin, const double &xmax, 
                      TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper)
    : OneDMesh<ELEMENT>(n_element,xmin,xmax,time_stepper_pt)
    {
     // Nodal positions etc. were created in constructor for OneDMesh<...>
     // so only need to set up binary tree forest
     this->setup_binary_tree_forest();
    }
   
  };
 
 
} // End of namespace

#endif


