//Geometric Multigrid.

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


//oomph-lib headers
#include "../generic/refineable_quad_mesh.h" 
#include "../generic/refineable_brick_element.h"
#include "geometric_multigrid.h"



namespace oomph
{


//========================================================================
/// Smoother: Perform max_iter smoothing steps for linear system Ax=b
/// with current rhs vector, b, starting with current solution vector, x.
/// Return residual vector r=b-Ax. Uses the default smoother (set
/// in the MGProblem constructor) which can be overloaded for specific 
/// problem.
//========================================================================
 void MGProblem::pre_smooth(const unsigned& max_iter, 
                            Vector<double>& residual)
 {
  // Call smoother
  pre_smoother_pt()->smoother_solve(max_iter,Rhs_mg,X_mg);

  // Get residual vector (discard the returned double)
  (void) residual_norm(residual);
 }



//========================================================================
/// Smoother: Perform max_iter smoothing steps for linear system Ax=b
/// with current rhs vector, b, starting with current solution vector, x.
/// Uses the default smoother (set
/// in the MGProblem constructor) which can be overloaded for specific 
/// problem.
//========================================================================
void MGProblem::post_smooth(const unsigned& max_iter)
{
 // solve by using a smoother
 post_smoother_pt()->smoother_solve(max_iter,Rhs_mg,X_mg);
 
}
 


//========================================================================
/// Return norm of residual r=b-Ax
//========================================================================
double MGProblem::residual_norm()
{ 
 // Number of dofs
 unsigned n_dof=ndof();
 Vector<double> residual(n_dof);
 
 return residual_norm(residual);
}
 


//========================================================================
/// Return norm of residual r=b-Ax and residual vector itself
//========================================================================
double MGProblem::residual_norm(Vector<double>& residual)
{
 // Number of dofs
 unsigned n_dof=ndof();
 
 // hierher: isn't there a matrix member function that does that?
 
 // Get residual
 double res_norm=0.0;
 Vector<double> temp_x_mg(n_dof);
 Matrix_mg.multiply(X_mg,temp_x_mg);
 for (unsigned i=0;i<n_dof;i++)
  {
   residual[i]=Rhs_mg[i];
   
   residual[i]-=temp_x_mg[i];
   
   res_norm+=residual[i]*residual[i];
  }
 
 return sqrt(res_norm); 
}


//========================================================================
/// Direct solver for linear system Ax=b
/// with current rhs vector, b. Result gets stored locally
/// in the MGProblem's solution vector, x. 
//========================================================================
void MGProblem::direct_solve()
{
 
 // Get solution by direct solve:
 Matrix_mg.solve(Rhs_mg,X_mg);
 
}



//========================================================================
/// Restrict residual (computed on current MG level) to
/// next coarser mesh and stick it into coarse mesh rhs vector.
/// Performed by multiplication with the transpose of the prolongation matrix.
//========================================================================
void MGProblem::restrict_full_weighting(const Vector<double>& residual)
{
 unsigned coarse_n_dof=Next_coarser_mg_level_pt->ndof();//coarse
 Vector<double> temp_rhs_mg(coarse_n_dof,0.0);
 
 // Multiply by transposed interpolation matrix
 interpolation_matrix().multiply_transpose(residual,temp_rhs_mg);

 //...and copy across
 for (unsigned i=0;i<coarse_n_dof;i++)
  {
   Next_coarser_mg_level_pt->rhs_mg(i)=temp_rhs_mg[i];
  } 
 
}

//========================================================================
/// Restrict residual (computed on current MG level) to
/// next coarser mesh and stick it into coarse mesh rhs vector.
//========================================================================
void MGProblem::restrict_injection(const Vector<double>& residual)
{
 
 // hierher: Could be made much more efficient.

 int *Row_start=interpolation_matrix().row_start();
 int *Column_index=interpolation_matrix().column_index();
 
 unsigned n_dof=ndof();
 for (unsigned long i=0;i<n_dof;i++)
  {  
   for (long k=Row_start[i];k<Row_start[i+1];k++)
    {
     unsigned long j=Column_index[k];
     if(1==interpolation_matrix()(i,j))//inefficient using (i,j)
      {
       Next_coarser_mg_level_pt->rhs_mg(j)=residual[i];
      }
    }
  }
 
}





//========================================================================
/// Restrict residual (computed on current MG level) to
/// next coarser mesh and stick it into coarse mesh rhs vector.
/// hierher: Needs more explanation!
//========================================================================
void MGProblem::restrict_sum_injection(const Vector<double>& residual)
{
 
//------ use sum(p^T)*rhs----------
 unsigned coarse_n_dof=Next_coarser_mg_level_pt->ndof();//coarse
 Vector<double>temp_rhs_mg(coarse_n_dof,0.0);

 unsigned n_dof=ndof();

 int z=0;
 for (unsigned j=0;j<coarse_n_dof;j++)
  {
   double sum=0.0;
   for (unsigned i=0;i<n_dof;i++)
    {
     if(1==interpolation_matrix()(i,j))//inefficient
      {
       z=i;
      }
     sum+=interpolation_matrix()(i,j);//inefficient
    }
   
   Next_coarser_mg_level_pt->rhs_mg(j)=sum*residual[z];
   
  }
 
}



//========================================================================
/// Interpolate solution at current level onto 
/// next finer mesh and correct the solution x at that level
//========================================================================
 void MGProblem::interpolate_and_correct()
 {
  unsigned n_dof_fine=Next_finer_mg_level_pt->ndof();
  Vector<double>temp_x_mg(n_dof_fine);
 
  // Interpolate...
  Next_finer_mg_level_pt->
   interpolation_matrix().multiply(X_mg,temp_x_mg);
 
  // ...and correct
  for (unsigned i=0;i<n_dof_fine;i++)
   {
    // Add coarse solution to finer level one:
    Next_finer_mg_level_pt->x_mg(i)+=temp_x_mg[i];
   }
 
 }



//========================================================================
/// Plot current rhs vector (assuming we're dealing with
/// scalar nodal data. Otherwise I don't know how to implement this...)
//========================================================================
 void MGProblem::plot_rhs(const std::string& filename)
 {
 
  std::ofstream some_file;
  some_file.open(filename.c_str());
 
  // Loop over all nodes
  unsigned nnod=mesh_pt()->nnode();
  for (unsigned j=0;j<nnod;j++)
   {
    // Pointer to node
    Node* nod_pt=mesh_pt()->node_pt(j);
   
    // Sanity check
    if (nod_pt->nvalue()!=1)
     {
      std::ostringstream error_stream;
      error_stream
       << "Sorry, not sure how to plot residuals for non-scalar problems " 
       << nod_pt->nvalue() 
       <<std::endl;
      unsigned dim=nod_pt->ndim();
      error_stream <<" the dimensionsssssss"<<dim<<std::endl;
      for (unsigned i=0;i<dim;i++)
       {
        error_stream << nod_pt->x(i) << " ";
       }
      error_stream << std::endl;
      throw OomphLibError(error_stream.str(),
                          "MGProblem::plot_rhs()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   
   
    // Plot rhs (or zero if not an unknown) -- consistent since RHS
    // represents the error and pinned values have zero error.
    unsigned dim=nod_pt->ndim();
    for (unsigned i=0;i<dim;i++)
     {
      some_file << nod_pt->x(i) << " ";
     }

    // Free or pinned?
    int e=nod_pt->eqn_number(0);
    if (e>=0)
     {
      some_file << rhs_mg(e) <<  std::endl;
     }
    else
     {
      some_file << 0.0 <<  std::endl;
     }
   }
  some_file.close();
 
 }



//========================================================================
/// Plot current mg solution vector (assuming we're dealing with
/// scalar nodal data. Otherwise I don't know how to implement this...)
//========================================================================
 void MGProblem::plot_x(const std::string& filename)
 {
 
  std::ofstream some_file;
  some_file.open(filename.c_str());
 
  // Loop over all nodes
  unsigned nnod=mesh_pt()->nnode();
  for (unsigned j=0;j<nnod;j++)
   {
    // Pointer to node
    Node* nod_pt=mesh_pt()->node_pt(j);
   
    // Sanity check
    if (nod_pt->nvalue()!=1)
     {
      std::ostringstream error_stream;
      error_stream 
       << "Sorry, not sure how to plot residuals for non-scalar problems " 
       << nod_pt->nvalue() 
       <<std::endl;
      unsigned dim=nod_pt->ndim();
      for (unsigned i=0;i<dim;i++)
       {
        error_stream << nod_pt->x(i) << " ";
       }
      error_stream << std::endl;
      throw OomphLibError(error_stream.str(),
                       "MGProblem::plot_x()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   

    unsigned dim=nod_pt->ndim();
    for (unsigned i=0;i<dim;i++)
     {
      some_file << nod_pt->x(i) << " ";
     }
    // Plot solution to mg problem at this level -- zero if not a dof
    // This is consistent because solution represents correction
    // to next finer level -- correction is zero if value is pinned
    int e=nod_pt->eqn_number(0);
    if (e>=0)
     {
      some_file << x_mg(e) << std::endl;
     }
    else
     {
      some_file << 0.0 << std::endl;
     }

   }
  some_file.close();
 
 }



//========================================================================
/// Setup multigrid operations: Create system matrix 
/// (or whatever else is needed to perform smoothing/direct solve), and
/// resize and initialise the rhs and solution vectors. 
/// Pass level and pointer to counter for number of v-cycles (for doc)
//========================================================================
 void MGProblem::setup_mg(const unsigned& level,
                          unsigned* v_cycle_counter_pt)
 {
  // Store level in overall hierarchy
  MG_level=level;
  
  // Pointer to counter for number of v cycles (for doc)
  V_cycle_counter_pt=v_cycle_counter_pt;
  
  // Resize solution and rhs vectors
  unsigned n_dof=ndof();
  X_mg.resize(n_dof);
  Rhs_mg.resize(n_dof);
 
  // Initialise solution to zero (RHS will be assigned later)
  for (unsigned i=0;i<n_dof;i++)
   {
    X_mg[i]=0.0;
   }
 
  // Compute system matrix at this level (based on the interpolated
  // values of the dofs which will soon be abused for all kinds of
  // things)
  Vector<double> residual(n_dof);
  get_jacobian(residual,Matrix_mg);
  
  // Setup smoother
  clock_t t_start=clock();
//want to set the GSsetup but solve useing pre,post options///check
  pre_smoother_pt()->smoother_setup(&Matrix_mg);
  post_smoother_pt()->smoother_setup(&Matrix_mg);
  clock_t t_end=clock(); 
  double total_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
  oomph_info << std::endl << "CPU time for smooth_setup  [sec]: "
       <<total_setup_time<< std::endl; 
 }




//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////




//======================================================================
///  Given the son_type of an element and a local node
/// number j in that element with nnode_1d nodes per coordinate
/// direction, return the local coordinate s in its
/// father element. 
//======================================================================
template<unsigned DIM>
void MGSolver<DIM>::level_up_local_coord_of_node(const unsigned& j,
                                                 const unsigned& son_type,
                                                 const unsigned& nnode_1d,
                                                 Vector<double>& s)
 {

  // Resize to the appropriate dimension
  s.resize(DIM);

  if(3==DIM)
   {
    double x_s_min, x_s_max, y_s_min, y_s_max, z_s_min, z_s_max; 
   
    switch(son_type)
     {
     case OcTreeNames::LDF:
      x_s_min=-1.0;   x_s_max=0.0;   
      y_s_min=-1.0;   y_s_max=0.0;
      z_s_min=0.0;    z_s_max=1.0;
      break;
   
     case OcTreeNames::LDB:
      x_s_min= -1.0;   x_s_max=0.0;
      y_s_min=-1.0;   y_s_max=0.0;
      z_s_min=-1.0;   z_s_max=0.0;
      break;
   
     case OcTreeNames::LUF:
      x_s_min= -1.0;   x_s_max=0.0;
      y_s_min=0.0;   y_s_max=1.0;
      z_s_min=0.0;   z_s_max=1.0;
      break;
   
     case OcTreeNames::LUB:
      x_s_min=-1.0;   x_s_max=0.0;
      y_s_min=0.0;   y_s_max=1.0;
      z_s_min=-1.0;   z_s_max=0.0;
      break;
   
   
     case OcTreeNames::RDF:
      x_s_min=0.0;   x_s_max=1.0;   
      y_s_min=-1.0;   y_s_max=0.0;
      z_s_min=0.0;   z_s_max=1.0;
      break;
   
     case OcTreeNames::RDB:
      x_s_min= 0.0;   x_s_max=1.0;
      y_s_min=-1.0;   y_s_max=0.0;
      z_s_min=-1.0;   z_s_max=0.0;
      break;
   
     case OcTreeNames::RUF:
      x_s_min= 0.0;   x_s_max=1.0;
      y_s_min=0.0;   y_s_max=1.0;
      z_s_min=0.0;   z_s_max=1.0;
      break;
   
     case OcTreeNames::RUB:
      x_s_min=0.0;   x_s_max=1.0;
      y_s_min=0.0;   y_s_max=1.0;
      z_s_min=-1.0;   z_s_max=0.0;
      break;
   
     default://no sons
      x_s_min=-1.0;   x_s_max=1.0;
      y_s_min=-1.0;   y_s_max=1.0;
      z_s_min=-1.0;   z_s_max=1.0;
      break;
   
     }
 
  
    unsigned j0=j%nnode_1d;
    unsigned j1=unsigned(double(j)/double(nnode_1d))%nnode_1d;
    unsigned j2=unsigned(double(j)/double(nnode_1d*nnode_1d));
    s[0]=x_s_min+double(j0)/double(nnode_1d-1)*(x_s_max-x_s_min);
    s[1]=y_s_min+double(j1)/double(nnode_1d-1)*(y_s_max-y_s_min);
    s[2]=z_s_min+double(j2)/double(nnode_1d-1)*(z_s_max-z_s_min);

   }
  else if(2==DIM)
   {
   
    double x_s_min, x_s_max, y_s_min, y_s_max; 
   
    switch(son_type)
     {
     case QuadTreeNames::SW:
      x_s_min=-1.0;   x_s_max=0.0;
      y_s_min=-1.0;   y_s_max=0.0;
      break;
     
     case QuadTreeNames::SE:
      x_s_min= 0.0;   x_s_max=1.0;
      y_s_min=-1.0;   y_s_max=0.0;
      break;
     
     case QuadTreeNames::NE:
      x_s_min= 0.0;   x_s_max=1.0;
      y_s_min=0.0;   y_s_max=1.0;
      break;
     
     case QuadTreeNames::NW:
      x_s_min=-1.0;   x_s_max=0.0;
      y_s_min=0.0;   y_s_max=1.0;
      break;
     
     default://was omega
      x_s_min=-1.0;   x_s_max=1.0;
      y_s_min=-1.0;   y_s_max=1.0;
      break;
     
               
     }

    unsigned i0=j%nnode_1d;
    unsigned i1=unsigned(double(j)/double(nnode_1d));
    s[0]=x_s_min+double(i0)/double(nnode_1d-1)*(x_s_max-x_s_min);
    s[1]=y_s_min+double(i1)/double(nnode_1d-1)*(y_s_max-y_s_min);


   }//endif

 }

 
//====================================================================
/// Setup the MG hierarchy and return the number of levels created.
//====================================================================
template<unsigned DIM>
unsigned MGSolver<DIM>::setup(MGProblem* problem_pt) 
{
 
 // Create copy of original problem on finest level
 MG_level.resize(1);
 
 MG_level[0]=problem_pt;
 
 // Setup MG data structures at this level and pass level and 
 // pointer to counter for v-cycles
 MG_level[0]->setup_mg(0,V_cycle_counter_pt);
 
 // Now keep making copies and unrefine them until we've reached
 // the coarsest possible level
 unsigned managed_to_unrefine=0;
 unsigned level=0;
 clock_t  t_m_start=clock();
 
//setup all the other levels
 while (0==managed_to_unrefine)//levels
  {
   // Make copy of present level problem
   MGProblem* new_problem_pt=MG_level[level]->make_copy();
   
   // Try to coarsen new level (returns 0 for success)
   managed_to_unrefine=new_problem_pt->unrefine_uniformly();
   
   // If we were able to unrefine, add to vector of levels
   if (0==managed_to_unrefine)
    {
     // Add to vector of MG levels to the end of the vector 
     //and increase counter
     MG_level.push_back(new_problem_pt);
     level++;
     
     // Setup MG data structures at this level
     MG_level[level]->setup_mg(level,V_cycle_counter_pt);
     
     // Setup pointers to respective finer/coarser levels
     MG_level[level-1]->next_coarser_mg_level_pt()=new_problem_pt;
     MG_level[level]->next_finer_mg_level_pt()=MG_level[level-1];
     
    }
   
  }//end while 
 

 clock_t t_m_end=clock();
 double total_setup_time=double(t_m_end-t_m_start)/CLOCKS_PER_SEC;
 oomph_info << std::endl 
            << "CPU time for creation of hierarchy of MG problems  [sec]: "
            <<total_setup_time<< std::endl; 
 
 
 // Setup the interpolation matrices
 //---------------------------------
 
 // Number of son elements
 unsigned n_sons;
 if(2==DIM)
  {
   n_sons=4;
  }
 else if(3==DIM)
  {
   n_sons=8; 
  }
 else
  {
   std::ostringstream error_message_stream;
   error_message_stream << "DIM should be 2 or 3 not " << DIM << std::endl;
   throw OomphLibError(error_message_stream.str(),
                       "MGSolver<DIM>::setup()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 

  // Vector of local coordinates in the element
  Vector<double> s(DIM);
  clock_t t_g_start=clock();

  //Loop over each level: 0 being the finest level
  unsigned nlev=nlevel();
  oomph_info << "Number of levels = "<<nlev << std::endl;
  for(unsigned level=0;level<nlev-1;level++)
   {

    // Set up a few helpers:
    unsigned coarse_level=level+1;
    unsigned fine_level=level;
   
    RefineableMeshBase* ref_coarse_mesh_pt=
     dynamic_cast<RefineableMeshBase*>
     (MG_level[coarse_level]->mesh_pt());
   
    RefineableMeshBase* ref_fine_mesh_pt=
     dynamic_cast<RefineableMeshBase*>
     (MG_level[fine_level]->mesh_pt());
   
    // unsigned coarse_n_element=ref_coarse_mesh_pt->nelement();
    unsigned fine_n_element=ref_fine_mesh_pt->nelement();
   
    unsigned coarse_n_unknowns=MG_level[coarse_level]->ndof();
    unsigned fine_n_unknowns=MG_level[fine_level]->ndof();
   

    // Mapping relating the pointers to related elements in the coarse and
    // fine meshes: coarse_mesh_element_pt[fine_mesh_element_pt]
    // If the element in the fine mesh has been unrefined between these two
    // levels, this map returns the father element in the coarsened mesh.
    // If this element in the fine mesh has not been unrefined,
    // the map returns the pointer to the same-sized equivalent
    // element in the coarsened mesh. 
    std::map<RefineableQElement<DIM>*,RefineableQElement<DIM>*> 
     coarse_mesh_reference_element_pt;

    
    // NOTE: THE LOGIC HERE IS A BIT CONVOLUTED... WE'RE WORKING
    // OUR WAY SEQUENTIALLY THROUGH THE ELEMENTS IN BOTH MESHES
    // DRAW A DIAGRAM TO MAKE SENSE OF IT...

    // Counter of elements in coarse and fine meshes: Start with element
    // zero in both meshes.
    unsigned e_coarse=0; // e
    unsigned e_fine=0; // e_k

    // While loop over fine elements (while because we're 
    // incrementing the counter internally if the element was
    // unrefined...)
    while(e_fine<fine_n_element)
     {
     
      // Pointer to element in fine mesh
      RefineableQElement<DIM>* el_fine_pt=
       dynamic_cast<RefineableQElement<DIM>*>
       (ref_fine_mesh_pt->finite_element_pt(e_fine));
     
      // Pointer to element in coarse mesh
      RefineableQElement<DIM>* el_coarse_pt=
       dynamic_cast<RefineableQElement<DIM>*>
       (ref_coarse_mesh_pt->finite_element_pt(e_coarse));

    

  
      // If the levels are different then has the elements in the fine
      // mesh have been unrefined between these two levels
      if(el_fine_pt->tree_pt()->level()!=
         el_coarse_pt->tree_pt()->level()) 
       {

        // The element the in fine mesh has been unrefined between these
        // two levels. Hence it
        // and its three brothers (ASSUMED to be stored consecutively
        // in the Mesh's vector of pointers to its constituent elements
        // -- we'll check this!)
        // share the same father element in the coarse mesh, currently
        // pointed to by el_coarse_pt.
        for(unsigned i=0;i<n_sons;i++)
         {

          // Set pointer to father element in coarse mesh
          coarse_mesh_reference_element_pt[dynamic_cast<
                                           RefineableQElement<DIM>*>
                                           (ref_fine_mesh_pt->
                                            finite_element_pt(e_fine))]=
           el_coarse_pt;

          // Increment counter for elements in fine mesh
          e_fine++;
         }
      
       }
   
      // The element in the fine mesh has not been unrefined between 
      // these two levels, so the
      // reference element is the same-sized equivalent element in the
      // coarse mesh:
      else
       {
        //the levels are the same/ not been refined this time
        coarse_mesh_reference_element_pt[el_fine_pt]=el_coarse_pt;

        // Increment counter for elements in fine mesh
        e_fine++;

       }

      // Increment counter for elements in coarse mesh
      e_coarse++;

     } //end of while loop for setting up element-coincidences...
   
    //To allow update of a row only once
    //We need to use stl vectors for bools
    std::vector<bool> contribution_made(fine_n_unknowns,false);
   
    //Storage vectors for CRmatrix and index iteration
    Vector<double> value;
    Vector<int> column_index;
    Vector<int> row_start(fine_n_unknowns+1);
    unsigned index=0;

    //Loop over each element in the fine level 
    for(unsigned k=0;k<fine_n_element;k++)
     {     
      // Pointer to element in the fine mesh
      RefineableQElement<DIM>* el_fine_pt=
       dynamic_cast<RefineableQElement<DIM>*>
       (ref_fine_mesh_pt->finite_element_pt(k));
     
      // Get the refrence element (either the father element or
      // the same-sized element) in the coarse mesh
      RefineableQElement<DIM>* el_coarse_pt=
       coarse_mesh_reference_element_pt[el_fine_pt];

      // Figure out the son type (set to OMEGA if no unrefinement 
      // took place)
      unsigned son_type;

      if(el_fine_pt->tree_pt()->level()!=el_coarse_pt->tree_pt()->
         level())
       {
        son_type=el_fine_pt->tree_pt()->son_type();
       }
      else
       {
        son_type=Tree::OMEGA;
       }

     
     
      //loop through all the nodes in the element in the fine mesh
      unsigned nnod=el_fine_pt->nnode();
      for(unsigned i=0;i<nnod;i++)
       {

        // Row number in interpolation matrix: Global equation number
        // of the dof stored at this node in the fine element
        int ii=el_fine_pt->node_pt(i)->eqn_number(0);
      
        // Is it a proper dof?
        if (ii>=0)
         {
        
          if(true==contribution_made[ii])
           {
           
           }
          else
           {
            row_start[index]=value.size();
            // Find the local coordinates s, of the present node,
            // in the reference element in the coarse mesh, 
            // given the element's son_type (e.g. SW,SE... )   
            level_up_local_coord_of_node(i,son_type,
                                         el_fine_pt->nnode_1d(),s);
          
            // Get  the shape fcts in the reference element
            Shape psi(el_coarse_pt->nnode());
            el_coarse_pt->shape(s,psi);

            // Auxiliary storage
            std::map<unsigned,double> contribution;
            Vector<unsigned> keys;
         
            // Loop through all the nodes in element reference element
            // in the coarse mesh
            unsigned nnod=el_coarse_pt->nnode();
            for(unsigned j=0;j<nnod;j++)
             {
              // Column number in interpolation matrix:
              // Global equation number
              // of the dof stored at this node in the coarse element
              int jj=el_coarse_pt->node_pt(j)->eqn_number(0);
           
              // If the value stored at this node is pinned or hanging
              if(jj<0)
               {
             
                // Hanging: Need to accumulate the contributions from the
                // master nodes
                if(el_coarse_pt->node_pt(j)->is_hanging())
                 {
               
                  // Loop over master nodes
                  HangInfo* hang_info_pt=el_coarse_pt->node_pt(j)->
                   hanging_pt();
                  unsigned nmaster=hang_info_pt->nmaster();
               
                  for(unsigned i_master=0; i_master<nmaster;i_master++)
                   {

                    // Pointer to master node
                    Node* master_node_pt = hang_info_pt->
                     master_node_pt(i_master);
                 
                    // Column number in interpolation matrix:
                    // Global equation 
                    // number of the dof stored at this master node for the 
                    // coarse element
                    int master_jj = master_node_pt->eqn_number(0);
                
                    // Is it a proper dof?
                    if(master_jj>=0)
                     {
                      if( psi(j)*hang_info_pt->master_weight(i_master)!=0.0)
                       {
                        contribution[master_jj]+=
                         psi(j)*hang_info_pt->master_weight(i_master);
                       }                        
                     }//not a boundary
         
                   }//loop though master nodes
               
                 } // end of hanging

               }
              // Node is not pinned or hanging:
              else
               {
                if(psi(j)!=0.0)
                 {
                
                  contribution[jj]+=psi(j);
                
                 }
                         
               }//end ifelse         
             } //loop over nodes j in coarse level
       

            // put the contributions into value
            for(std::map<unsigned,double>::iterator it = contribution.begin();
                it!=contribution.end(); ++it)
             {
              if(it->second!=0)
               {
                value.push_back(it->second);
                column_index.push_back(it->first);
               }
             }//end contribution
           
            index++;
            // set contribution to true, means the row has been filled once
            contribution_made[ii]=true;  
           }// if contribution_made
         
         }//end normal node for row //if(ii =-1)
         
       } // end of loop over nodes for i
     
     }//loop over elements in fine level
 
    row_start[index]=value.size();
   
    MG_level[level]->interpolation_matrix_set(value,column_index,
                                              row_start,coarse_n_unknowns);
   
   }//loop through each level
 

  clock_t t_g_end=clock();
  double total_G_setup_time=double(t_g_end-t_g_start)/CLOCKS_PER_SEC;
  oomph_info << std::endl << "CPU time for glyn mapping setup solve [sec]: "
       <<total_G_setup_time<< std::endl;

  // Return the number of levels
  return level+1;
 
 }//end setup
 


//====================================================================
/// Linear solver
//====================================================================
template<unsigned DIM>
void MGSolver<DIM>::solve(Problem* const& problem_pt, Vector<double>& result)
{
 
 // Upcast to MG problem
 MGProblem* mg_problem_pt=dynamic_cast<MGProblem*>(problem_pt);
 
#ifdef PARANOID
 if (mg_problem_pt==0)
  {
   throw OomphLibError("Couldn't cast to MGProblem ",
                       "MGSolver<DIM>::solve()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 
 // Open file to doc convergence 
 std::ofstream convergence_file;
 convergence_file.open("RESLT_HEAT_mg/mg_convergence.dat");
 
 clock_t t_start=clock();

 // Setup MG hierarchy -- might be able to skip this if the
 // mesh hasn't changed since last solve. Check at some point
 unsigned nlevel=setup(mg_problem_pt);
 
 clock_t t_end=clock();
 double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
 oomph_info << std::endl << "CPU time for overall setup for MG solve [sec]: " 
      << total_time << std::endl;
 
//  // Loop over all levels and doc the mesh hierarchy
//  std::ofstream some_file;
//  char filename[100];
//  for (unsigned i=0;i<nlevel;i++)
//   {
//    sprintf(filename,"RESLT_HEAT_mg/mg_level%i.dat",i);
//    some_file.open(filename);
//    MG_level[i]->mesh_pt()->output(some_file);
//    some_file.close();
//   }

 
 // Get the residual vector of the original nonlinear problem
 unsigned n_dof=mg_problem_pt->ndof();
 Vector<double> fine_nonlin_residual(n_dof);
 mg_problem_pt->get_residuals(fine_nonlin_residual);
 
 // Setup RHS and solution vector at the current (fine) level
 for (unsigned i=0;i<n_dof;i++)
  {
   MG_level[0]->rhs_mg(i)=fine_nonlin_residual[i];
   // Use zero initial guess
   MG_level[0]->x_mg(i)=0.0;
  }
 

// hierher
//  oomph_info<<"solve directly"<<std::endl;
//  // Get direct solution and doc
//  {
//   t_start=clock();
  
//   MG_level[0]->direct_solve();
  
//   t_end=clock();
  
//   // Doc solution on finest level
//   char cfilename[100];
//   sprintf(cfilename,"RESLT_HEAT_mg/v_soln_exact.dat");
//   std::string filename=cfilename;
//   MG_level[0]->plot_x(filename);
  
//   // Reset 
//   for (unsigned i=0;i<n_dof;i++)
//    {
//     MG_level[0]->rhs_mg(i)=fine_nonlin_residual[i];
//     // Zero initial guess
//     MG_level[0]->x_mg(i)=0.0;
//    }
  
//   total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
//   oomph_info << std::endl << "CPU time for direct solve [sec]: " 
//        << total_time << std::endl;
//  }
 
//   oomph_info<<"solve by MG"<<std::endl;
//   //needs to be a tolerance


  // Outer loop over V-cycles
  //-------------------------
  t_start=clock();
 
  double normalised_residual_norm;
  unsigned v_counter=0;

  normalised_residual_norm=MG_level[0]->residual_norm();
  oomph_info << "residual on finest level for v-cycle: " << v_counter << " "   
       << normalised_residual_norm << std::endl; 
  while((normalised_residual_norm>Tolerance)&&(v_counter!=Nvcycle))
   {
    
    // Doc solution on finest level
    // char cfilename[100];
    // sprintf(cfilename,"RESLT_HEAT_mg/v_soln%i.dat",v);
    // std::string filename=cfilename;
    // MG_level[0]->plot_x(filename);
    
    
    //sprintf(cfilename,"RESLT_HEAT_mg/v_rhs%i.dat",v);
    //filename=cfilename;
    //MG_level[0]->plot_rhs(filename);
     
 
    convergence_file << v_counter << " "  <<
     normalised_residual_norm << std::endl;
    
    // Set counter for number of cycles (for doc)
    *V_cycle_counter_pt=v_counter;

 
    // Loop downwards over all levels that have coarser levels beneath them
    //---------------------------------------------------------------------
    for (unsigned i=0;i<nlevel-1;i++)
     {
     
      unsigned n_dof=MG_level[i]->ndof();
      Vector<double> residual(n_dof,0.0);
     
      //initialise x_mg to 0.0 except for the finest level
      if(i!=0)
       {
        unsigned test_n_dof=MG_level[i]->ndof();
        for (unsigned temp_i=0;temp_i<test_n_dof;temp_i++)
         {
          MG_level[i]->x_mg(temp_i)=0.0;
         } 
       }

      // Perform a few pre-smoothing steps and return 
      // vector that contains the residuals of the linear system 
      // at this level.
      MG_level[i]->pre_smooth(Npre_smooth,residual);
      

//       }

      // hierher: this can probably go (should anyway..)
//       else
//        {

//         // hierher: Why do we call post_smooth on the way down?
//         MG_level[i]->post_smooth(Npre_smooth);
//         // Get residual vector (discard the returned double)
//         (void)MG_level[i]->residual_norm(residual);
//        }
     
     
      // Restrict the residual to the next coarser mesh and
      // assign it to the rhs vector at that level
      if(1==Restrict_flag)
       {
        MG_level[i]->restrict_sum_injection(residual);
       }
      else if(2==Restrict_flag)
       {
        MG_level[i]->restrict_injection(residual);
       }
      else if(3==Restrict_flag)
       {
        MG_level[i]->restrict_full_weighting(residual);
       }

     }//moving down vcycle
   
  
    // Reached the lowest level: Do a direct solve, using the 
    //-------------------------------------------------------
    // rhs vector obtained by restriction from above. 
    //-----------------------------------------------
    MG_level[nlevel-1]->direct_solve();
   
   
    // Loop upwards over all levels that have finer levels above them 
    //---------------------------------------------------------------
    for (unsigned i=nlevel-1;i>0;i--)
     {
     
      // Interpolate solution at current level onto 
      // next finer mesh and correct the solution x at that level
      MG_level[i]->interpolate_and_correct();

      // Perform a few post-smoothing steps (ignore
      // vector that contains the residuals of the linear system 
      // at this level)
      MG_level[i-1]->post_smooth(Npost_smooth);
    
     }
     
    v_counter++;
   
    normalised_residual_norm=MG_level[0]->residual_norm();
    oomph_info << "residual on finest level for v-cycle: " << v_counter << " "   
         << normalised_residual_norm << std::endl;

   }//end v cycles

  t_end=clock();
  double tot_time=double(t_end-t_start)/CLOCKS_PER_SEC;
  oomph_info << std::endl << "CPU time for MG solve [sec]: "
       <<tot_time<< std::endl; 


  // Doc solution on finest level
  {
   char cfilename[100];
   sprintf(cfilename,"RESLT_HEAT_mg/v_soln%i.dat",Nvcycle);//result
   std::string filename=cfilename;
   MG_level[0]->plot_x(filename);
    
   //  sprintf(cfilename,"RESLT_HEAT_mg/v_rhs%i.dat",Nvcycle);//rhs
   //   filename=cfilename;
   //   MG_level[0]->plot_rhs(filename);
 
   convergence_file << Nvcycle  << " "  << normalised_residual_norm <<
    std::endl;
  }


  // double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
  // oomph_info << std::endl << "CPU time for GMG solve [sec]: " 
  //     << total_time << std::endl;
  
  // We're done. The solution is the solution at the finest level
  for (unsigned i=0;i<n_dof;i++)
   {
    result[i]=MG_level[0]->x_mg(i);
   }

 }
 
 
 
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//======================================================================
//Smoothers and joint smoothers and preconditioners
//======================================================================
 

//======================================================================
//Gauss Seidel smoother/solver
//======================================================================


//=======================================================================
/// The actual Gauss Seidel iteration, implemented for a CRDoubleMatrix
//=======================================================================
template<>
void GaussSeidel<CRDoubleMatrix>::GS_lower_iterations(
 const unsigned &max_iter,
 const Vector<double> &local_residual,
 Vector<double> &x)
{
 
 unsigned n_dof=x.size();
  
  //Calculate the 2 norm
  double add_squared=0.0;
  for(unsigned i=0;i<n_dof;i++)
   {          
    add_squared+=local_residual[i]*local_residual[i];
   }
  double norm_res=sqrt(add_squared);
  double norm_f=norm_res;
  
  Vector<double> current_residual(n_dof);
 
  Iterations=0;

  // Start of the main GS loop
  while((norm_res>Tolerance)&&(Iterations!=max_iter))
   {
  
    int *Row_start=dynamic_cast<CRDoubleMatrix*>(Matrix_pt)->row_start();
    int *Column_index =dynamic_cast<CRDoubleMatrix*>(Matrix_pt)->
     column_index();

    double *Value=dynamic_cast<CRDoubleMatrix*>(Matrix_pt)->value();
    double a_ii=1;
    
    for (unsigned i=0;i<n_dof;i++)
     {
      double dummy=local_residual[i];
      unsigned k=Row_start[i];
      while (unsigned (Column_index[k])<i)
       {
        unsigned j=Column_index[k];
        double a_ij=Value[k];
        dummy-=a_ij*x[j];//represents the new x_mg
        k++;
       }
       
      if(unsigned(Column_index[k])==i)
       {
        a_ii=Value[k];//possibly
        k++;
       }else
       {
        oomph_info<<"error no diagonal a_ii line 288"<<std::endl;
       }
       
      while (k<unsigned(Row_start[i+1]))
       {
        unsigned j=Column_index[k];
        double a_ij=Value[k];
        dummy-=a_ij*x[j];//represents the old x_mg
        k++;
       }
      x[i]=dummy/a_ii;
     }//end GS

    // Get residual
    Matrix_pt->residual(x,local_residual,current_residual);
    
    //calculate the 2 norm
    add_squared=0.0;
    for(unsigned i=0;i<n_dof;i++)
     {
      add_squared+=current_residual[i]*current_residual[i];
     }
    
    norm_res=sqrt(add_squared)/norm_f;
    Iterations++;
    
    unsigned Doc_convergence_history=false;
    if (Doc_convergence_history)
     {
      oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
                << norm_res <<std::endl;
     }
    
   }//end while (number of smoothes or relaxations)
    
  oomph_info << std::endl;
  oomph_info << "GS converged/iteration. Residual norm: " <<
   norm_res << std::endl;
  oomph_info << "Number of iterations: " <<
   Iterations << std::endl;
  oomph_info << std::endl;
  
  //Copy result into result
  // result = x;
  


 }


//==================================================================
///The actual Gauss Seidel iteration, implemented very
/// inefficiently for all other matrices
//==================================================================
template<>
void GaussSeidel<DenseDoubleMatrix>:: GS_lower_iterations(const 
                                                          unsigned &max_iter,
                                         const Vector<double> &local_residual,
                                                          Vector<double> &x)
{
 
 unsigned n_dof=x.size();
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   
   add_squared+=local_residual[i]*local_residual[i];
   
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;
 
 Vector<double> current_residual(n_dof);
 Iterations=0;  
 
 // Start of the main GS loop
 while((norm_res>Tolerance)&&(Iterations!=max_iter))
  {
   
   // Loop over rows
   for(unsigned i=0;i<n_dof;i++)
    {
     
     double dummy=local_residual[i];
     for (unsigned j=0;j<i;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     for (unsigned j=(i+1);j<n_dof;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     x[i]=dummy/(*Matrix_pt)(i,i);
     }
   
    // Get residual
   Matrix_pt->residual(x,local_residual,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   Iterations++;
   
   if (Doc_convergence_history)
    {
     oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
               << norm_res <<std::endl;
    }
   
  }//end while (number of smoothes or relaxations)
 
 oomph_info << std::endl;
 oomph_info << "GS converged. Residual norm: " << norm_res << std::endl;
 oomph_info << "Number of iterations to convergence: " <<
  Iterations << std::endl;
 oomph_info << std::endl;
 
}

/// To Do uses general notation at the moment
//=======================================================================
/// The actual Gauss Seidel iteration, implemented for a CRDoubleMatrix
//=======================================================================
template<>
void GaussSeidel<CCDoubleMatrix>:: GS_lower_iterations(const 
                                                       unsigned &max_iter,
                                         const Vector<double> &local_residual,
                                                       Vector<double> &x)
{
 
 unsigned n_dof=x.size();
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   
   add_squared+=local_residual[i]*local_residual[i];
   
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;
 
 Vector<double> current_residual(n_dof);
 Iterations=0;  
 
 // Start of the main GS loop
 while((norm_res>Tolerance)&&(Iterations!=max_iter))
  {
   
   // Loop over rows
   for(unsigned i=0;i<n_dof;i++)
    {
     
     double dummy=local_residual[i];
     for (unsigned j=0;j<i;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     for (unsigned j=(i+1);j<n_dof;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     x[i]=dummy/(*Matrix_pt)(i,i);
     }
   
    // Get residual
   Matrix_pt->residual(x,local_residual,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   Iterations++;
   
   if (Doc_convergence_history)
    {
     oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
               << norm_res <<std::endl;
    }
   
  }//end while (number of smoothes or relaxations)
 
 oomph_info << std::endl;
 oomph_info << "GS converged. Residual norm: " << norm_res << std::endl;
 oomph_info << "Number of iterations to convergence: " <<
  Iterations << std::endl;
 oomph_info << std::endl;
 
}


//=======================================================================
/// The actual Gauss Seidel iteration, using the upper triangle,
/// implemented for a DenseDoubleMatrix
//=======================================================================
template<>
void UpperGaussSeidel<DenseDoubleMatrix>:: GS_upper_iterations(
 const unsigned &max_iter,
 const Vector<double> &local_residual,
 Vector<double> &x)
{
 
 unsigned n_dof=x.size();
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   
   add_squared+=local_residual[i]*local_residual[i];
   
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;
 
 Vector<double> current_residual(n_dof);
 Iterations=0;  
 
 // Start of the main GS loop
 while((norm_res>Tolerance)&&(Iterations!=max_iter))
  {
   ///works backwards to give x^(k+1)=1/D(b-Lx^k-Ux^(k+1))
   // Loop over rows

   for(unsigned i=n_dof-1;i>0;i--)
    {
     double dummy=local_residual[i];
     for (unsigned j=0;j<i;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     for (unsigned j=(i+1);j<n_dof;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     x[i]=dummy/(*Matrix_pt)(i,i);
     }
     
    // Get residual
   Matrix_pt->residual(x,local_residual,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   Iterations++;
   
   if (Doc_convergence_history)
    {
     oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
               << norm_res <<std::endl;
    }
   
  }//end while (number of smoothes or relaxations)
 
 oomph_info << std::endl;
 std::cout << "GS iteration. Residual norm: " << norm_res << std::endl;
 std::cout << "Number of iterations to convergence: " <<
  Iterations << std::endl;
 oomph_info << std::endl;
 
}//upper GS


//=======================================================================
/// The actual Gauss Seidel iteration, using the upper triangle,
/// implemented for a DenseDoubleMatrix
//=======================================================================
template<>
void UpperGaussSeidel<CRDoubleMatrix>:: GS_upper_iterations(
 const unsigned &max_iter,
 const Vector<double> &local_residual,
 Vector<double> &x)
{
 
 unsigned n_dof=x.size();
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   add_squared+=local_residual[i]*local_residual[i];
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;
 
 Vector<double> current_residual(n_dof);
 Iterations=0;  
 
 // Start of the main GS loop
 while((norm_res>Tolerance)&&(Iterations!=max_iter))
  {
   ///works backwards to give x^(k+1)=1/D(b-Lx^k-Ux^(k+1))
   // Loop over rows
   int *Row_start=dynamic_cast<CRDoubleMatrix*>(Matrix_pt)->row_start();
   int *Column_index =dynamic_cast<CRDoubleMatrix*>(Matrix_pt)->
    column_index();

   double *Value=dynamic_cast<CRDoubleMatrix*>(Matrix_pt)->value();
   double a_ii=1;


   for (unsigned i=n_dof-1;i>0;i--)
    {
     double dummy=local_residual[i];
     unsigned k=Row_start[i];
     while (unsigned (Column_index[k])<i)
      {
       unsigned j=Column_index[k];
       double a_ij=Value[k];
       dummy-=a_ij*x[j];//represents the new x_mg
       k++;
      }
     
     if(unsigned(Column_index[k])==i)
      {
       a_ii=Value[k];//possibly
       k++;
      }else
      {
       oomph_info<<"error no diagonal a_ii line 288"<<std::endl;
      }
     
     while (k<unsigned(Row_start[i+1]))
      {
       unsigned j=Column_index[k];
       double a_ij=Value[k];
       dummy-=a_ij*x[j];//represents the old x_mg
       k++;
      }
     x[i]=dummy/a_ii;
    }//end GS
   
     
    // Get residual
   Matrix_pt->residual(x,local_residual,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   Iterations++;
   
   if (Doc_convergence_history)
    {
     oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
               << norm_res <<std::endl;
    }
   
  }//end while (number of smoothes or relaxations)
 
 oomph_info << std::endl;
 std::cout << "GS iteration. Residual norm: " << norm_res << std::endl;
 std::cout << "Number of iterations to convergence: " <<
  Iterations << std::endl;
 oomph_info << std::endl;
 
}//upper GS


///To do uses general notation very inefficent
//==================================================================
///The actual Gauss Seidel iteration, implemented very
/// inefficiently for all other matrices
//==================================================================
template<>
void UpperGaussSeidel<CCDoubleMatrix>:: GS_upper_iterations(
 const unsigned &max_iter,
 const Vector<double> &local_residual,
 Vector<double> &x)
{
 
 unsigned n_dof=x.size();
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   
   add_squared+=local_residual[i]*local_residual[i];
   
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;
 
 Vector<double> current_residual(n_dof);
 Iterations=0;  
 
 // Start of the main GS loop
 while((norm_res>Tolerance)&&(Iterations!=max_iter))
  {
   ///works backwards to give x^(k+1)=1/D(b-Lx^k-Ux^(k+1))
   // Loop over rows

   for(unsigned i=n_dof-1;i>0;i--)
    {
     double dummy=local_residual[i];
     for (unsigned j=0;j<i;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     for (unsigned j=(i+1);j<n_dof;j++)
      {
       
       dummy-=(*Matrix_pt)(i,j)*x[j];
       
      }
     x[i]=dummy/(*Matrix_pt)(i,i);
     }
     
    // Get residual
   Matrix_pt->residual(x,local_residual,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   Iterations++;
   
   if (Doc_convergence_history)
    {
     oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
               << norm_res <<std::endl;
    }
   
  }//end while (number of smoothes or relaxations)
 
 oomph_info << std::endl;
 std::cout << "GS iteration. Residual norm: " << norm_res << std::endl;
 std::cout << "Number of iterations to convergence: " <<
  Iterations << std::endl;
 oomph_info << std::endl;
 
}//upper GS



//==================================================================
///The actual Gauss Seidel iteration, implemented very
/// inefficiently for a general matrix.
//==================================================================
template <typename MATRIX>
void Jacobi<MATRIX>::jacobi_iterations(const unsigned &max_iter,
                                       const Vector<double> &local_residual,
                                       Vector<double> &x)
{
 unsigned n_dof=x.size();
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   add_squared+=local_residual[i]*local_residual[i];
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;
 
 Vector<double> new_x(n_dof);
 Vector<double> current_residual(n_dof);
 Iterations=0;  
// Start of the main jacobi loop
 while((norm_res>Tolerance)&&(Iterations!=max_iter))
  {
   
   for (unsigned i=0;i<n_dof;i++)
    {
     new_x[i]=local_residual[i];
     for (unsigned j=0;j<i;j++)
      {
       new_x[i]-=(*Matrix_pt)(i,j)*x[j];
      }
     for (unsigned j=i+1;j<n_dof;j++)
      {
       new_x[i]-=(*Matrix_pt)(i,j)*x[j];
      }
     new_x[i]/=(*Matrix_pt)(i,i);
    }
   for (unsigned i=0;i<n_dof;i++)
    {
     x[i]=new_x[i];
    }
   
   
   // Get residual
   Matrix_pt->residual(x,local_residual,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   Iterations++;
   
   if (Doc_convergence_history)
    {
     oomph_info<< "Iteration: " << Iterations << "; norm of residual: "
               << norm_res <<std::endl;
    }
   
  }//end while (number of smoothes or relaxations)
 
 oomph_info << std::endl;
 oomph_info << "Jacobi converged. Residual norm: " << norm_res << std::endl;
 oomph_info << "Number of iterations to convergence: " <<
  Iterations << std::endl;
 oomph_info << std::endl;
 
}

 template class Jacobi<CCDoubleMatrix>;
 template class Jacobi<DenseDoubleMatrix>;
 template class Jacobi<CRDoubleMatrix>;
 

//========================================================================
/// setup ILU(0) preconditioner for Matrices of CRDoubleMatrix Type
/// takes a matrix and factorises it into upper and lower CRDoubleMatricies
//========================================================================
 void ILUZero<CRDoubleMatrix>::ILU_setup(
  DoubleMatrixBase* matrix_pt)
 {	
  // cast the Double Base Matrix to Compressed Column Double Matrix
  CRDoubleMatrix* cr_matrix_pt = dynamic_cast<CRDoubleMatrix*>(matrix_pt);

  oomph_info <<"smoother setup ILU"<<std::endl;
  // number of rows in matrix
  int n_row=cr_matrix_pt->nrow();
 
  // declares variables to store number of non zero entires in L and U
  int l_nz = 0; 
  int u_nz = 0;
 
  // create space for m matrix
  int* m_row_start;
  int* m_column_index;
  double* m_value;
 
  // get the m matrix
  m_row_start = cr_matrix_pt->row_start();
  m_column_index = cr_matrix_pt->column_index();
  m_value = cr_matrix_pt->value();

  // find number non zero entries in L and U
  for (int i = 0; i < n_row; i++)
   {
    for (int j = m_row_start[i]; j < m_row_start[i+1]; j++)
     {
      if (m_column_index[j] < i)
       {
        l_nz++;
       }
      else
       {
        u_nz++;
       }
     }
   }
 
  //resize vectors to store the data for the lower prior to building the 
  //matrices
  L_row_start.resize(n_row+1);
  L_column_index.resize(l_nz);
  L_value.resize(l_nz);
 
  // and the upper matrix
  U_row_start.resize(n_row+1);
  U_column_index.resize(u_nz);
  U_value.resize(u_nz);
 
  // set first column pointers to zero
  L_row_start[0] = 0;
  U_row_start[0] = 0;

  //split the matrix into L and U
  for (int i = 0; i < n_row; i++)
   {
    L_row_start[i+1] = L_row_start[i];
    U_row_start[i+1] = U_row_start[i];
    for (int j = m_row_start[i]; j < m_row_start[i+1]; j++)
     {
      if (m_column_index[j] < i)
       {
        int k = L_row_start[i+1]++;
        L_value[k] = m_value[j];
        L_column_index[k] = m_column_index[j];
       }
      else
       {
        int k = U_row_start[i+1]++;
        U_value[k] = m_value[j];
        U_column_index[k] = m_column_index[j];
       }
     }
   }
 
  // check the row or column indexes within each column or row are in the
  // correct order for the U matrix
  for (unsigned i = 0; i < static_cast<unsigned>(n_row); i++)
   {
    for (unsigned j = U_row_start[i]; j < U_row_start[i+1]-1; j++)
     {
      if (U_column_index[j] >= U_column_index[j+1])
       {
        throw OomphLibError( 
         "Column Indices of U in CRDoubleMatrix format are not in the correct order",
         "ILUZeroPreconditioner<CRDoubleMatrix>::setup",
         OOMPH_EXCEPTION_LOCATION);
       }
     }
   }


  // check the row or column indexes within each column or row are in the
  // correct order for the L matrix
  for (int i = 0; i < n_row; i++)
   {
    for (int j = L_row_start[i]; j < int(L_row_start[i+1]-1); j++)
     {
      if (L_column_index[j] >= L_column_index[j+1])
       {
        throw OomphLibError( 
         "Column Indices of L in CRDoubleMatrix format are not in the correct order",
         "ILUZeroPreconditioner<CRDoubleMatrix>::setup",
         OOMPH_EXCEPTION_LOCATION);
       }
     }
   }
	
  // factorise matrix	
  unsigned i, j, pn, qn, rn; pn = 0; qn=0; rn = 0;
  double multiplier;
  for (i = 1; i < static_cast<unsigned>(n_row); i++) {
   for (j = L_row_start[i]; j < L_row_start[i+1]; j++)
    {
     pn = U_row_start[L_column_index[j]];
     multiplier = (L_value[j] /= U_value[pn]);
     qn = j + 1;
     rn = U_row_start[i];
     for (pn++; pn < U_row_start[L_column_index[j]+1] && U_column_index[pn] < i;
          pn++)
      {
       while (qn < L_row_start[i+1] && L_column_index[qn] < U_column_index[pn])
        qn++;
       if (qn < L_row_start[i+1] && U_column_index[pn] == L_column_index[qn])
        L_value[qn] -= multiplier * U_value[pn];
      }
     for ( ; pn < U_row_start[L_column_index[j]+1]; pn++)
      {
       while (rn < U_row_start[i+1] && U_column_index[rn] < U_column_index[pn])
        rn++;
       if (rn < U_row_start[i+1] && U_column_index[pn] == U_column_index[rn])
        U_value[rn] -= multiplier * U_value[pn];
      }
    }
  }
 }//richards changed the name to be general




//========================================================================
/// \short Apply ILU(0) preconditioner for CRDoubleMatrix: Solve Ly=r 
/// then Uz=y
/// and return z
//========================================================================
 void ILUZero<CRDoubleMatrix>::smoother_solve
 (const unsigned &max_iter,
  const Vector<double> &local_residual,
  Vector<double> &x)
 {
  // # of rows in the matrix

  // Number of dofs
  unsigned n_dof=local_residual.size();

  Vector<double> new_x(n_dof,0.0);
  Vector<double> new_res(n_dof);

  for (unsigned iter=0;iter<max_iter;iter++)
   {
     
    //need to take res=Ax-f when going back up the mg lvels
      
    ILU_matrix_pt->residual(x,local_residual,new_res);
     
    //solve A'e=r
    ILU_solve(new_res,new_x);

    //correct error x'=e+x    
    for (unsigned iter=0;iter<n_dof;iter++)
     { 

      x[iter]+=new_x[iter];

     }

   }//end number of nsmooth

 }//ILU smoother solve


//=============================================================================
/// \short Apply ILU(0) preconditioner for CRDoubleMatrix: Solve Ly=r then Uz=y
///  and return z
//=============================================================================
 void ILUZero<CRDoubleMatrix>::ILU_solve(const Vector<double>& r,
                                         Vector<double>& z)
 {
  // # of rows in the matrix
  int n_row=r.size();
 
  // copy r to z
  for (int i = 0; i < n_row; i++)
   {
    z[i] = r[i];
   }
 
  // solve Ly=r (note L matrix is unit and diagonal is not stored)
  double t;
  for (int i = 0; i < n_row; i++)
   {
    t = 0;
    for (unsigned j = L_row_start[i]; j <  L_row_start[i+1]; j++)
     {
      t = t + L_value[j] * z[L_column_index[j]];
     }
    z[i] = z[i] - t;
   }
 
  // solve Uz=y
  for (int i = n_row-1; i >= 0; i--)
   {
    t = 0;
    for (unsigned j = U_row_start[i]+1; j < U_row_start[i+1]; j++)
     {
      t = t + U_value[j] * z[U_column_index[j]];
     }
    z[i] = z[i] - t;
    z[i] = z[i] / U_value[U_row_start[i]];
   }
 }

 template class ILUZero<CCDoubleMatrix>;
 template class ILUZero<DenseDoubleMatrix>;
 //Intel compiler complains about this line.
//template class ILUZero<CRDoubleMatrix>;


 template class MGSolver<2>;
 template class MGSolver<3>;

}//oomph
