// geometric multigrid

//Include guards
#ifndef OOMPH_MGPROBLEM_HEADER
#define OOMPH_MGPROBLEM_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


//oomph-lib headers
#include "../generic/matrices.h"
#include "../generic/problem.h"
#include "../generic/tree.h"
#include "../generic/iterative_linear_solver.h"


namespace oomph
{
 

//====================================================================
/// Smoother class:
/// The smoother class is designed for to be used in conjunction with
/// multigrid. The action of the smoother should reduce the high frequency 
/// errors. These methods are inefficient as stand-alone solvers
//====================================================================
 class Smoother
 {
  
   public:
  
  /// Empty constructor
  Smoother(){};
  
  /// Virtual empty destructor
  virtual ~Smoother(){};
  
  /// \short The smoother_solve function performs n_smooth iterations
  /// on the system Ae=r.
  virtual void smoother_solve(const unsigned &n_smooth,
                              const Vector<double> &r,
                              Vector<double> &e)=0;
  
  
  /// Setup the smoother for the matrix specified by the pointer
  virtual void smoother_setup(DoubleMatrixBase* matrix_pt)=0;

 
 };


//=========================================================================
/// Gauss Seidel "solver" templated by matrix type. The "solver"
/// exists in many different incarnations: Its an IterativeLinearSolver,
/// a Preconditioner and a Smoother, all of which use the
/// same basic iteration. 
/// hierher: ToDo Move into iterative linear solver
//=========================================================================
template<typename MATRIX>
class GaussSeidel :  public Smoother, public IterativeLinearSolver,
                     public Preconditioner
{
 
  public:
 
 /// Empty constructor
 GaussSeidel(){};
 
 /// Empty destructor
 ~GaussSeidel(){};

 /// Broken copy constructor
 GaussSeidel(const GaussSeidel&) 
  { 
   BrokenCopy::broken_copy("GaussSeidel");
  } 
 
 /// Broken assignment operator
 void operator=(const GaussSeidel&) 
  {
   BrokenCopy::broken_assign("GaussSeidel");
  }

 
 /// Setup: Pass pointer to the matrix and store in cast form
 void smoother_setup(DoubleMatrixBase* matrix_pt)
  {
   Matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  }
 
 /// Smoother performs  nsmooth Gauss Seidel iterations on the
 /// system A e = r
 void smoother_solve(const unsigned &nsmooth, 
                     const Vector<double>& r,
                     Vector<double> &e)
  {
   GS_lower_iterations(nsmooth, r, e);
  }
 
 
 /// Use Gauss Seidel iteration as an IterativeLinarSolver: This
 /// obtains the Jacobian matrix J and the residual vector r
 /// (needed for the Newton method) from the problem's get_jacobian
 /// function and returns the result of Jx=r.
 void solve(Problem* const &problem_pt, Vector<double> &result)
  {
   
   //Find # of degrees of freedom (variables)
   unsigned n_dof = problem_pt->ndof();
 
   //Get the jacobian and residual of the nonlinear problem
   MATRIX jacobian;
  
   Vector<double> f(n_dof);
   problem_pt->get_jacobian(f,jacobian);
    
   // Initial guess is zero so the residual is equal to the RHS
   Vector<double> x(n_dof,0.0);
   Vector<double> local_residual(n_dof);
   for(unsigned i=0;i<n_dof;i++)
    {   
     local_residual[i]=f[i];
    }
 
   //Setup
 
  smoother_setup(&jacobian);
  
   // Solve and copy result
   GS_lower_iterations(Max_iter,local_residual,x);
   result=x;
  
  }
   
 
 /// Number of iterations taken 
 unsigned iterations()
  {
   return Iterations;
  }
 
 
  private:
 
 ///  \short This is where the actual work is done -- different
 /// implementations for different matrix types.
 void GS_lower_iterations(const unsigned &nsmooth, const Vector<double>& r,
                    Vector<double> &e);
 
  /// Pointer to the matrix
  MATRIX* Matrix_pt;

  /// Number of iterations taken
  unsigned Iterations; 
 
 };// Gauss-Seidel 
// needs to be hear so can set Gauss Seidel to be defult


//=====================================================
/// MG problem
//=====================================================
class MGProblem : public virtual Problem
{
 
  public:
 
 /// Constructor. Initialise pointers to coarser and finer levels
 MGProblem() : MG_level(0), Next_coarser_mg_level_pt(0), 
  Next_finer_mg_level_pt(0), V_cycle_counter_pt(0) // hierher kill?
  {
   Pre_Smoother_pt=new GaussSeidel<CRDoubleMatrix>;
   Post_Smoother_pt=Pre_Smoother_pt;
  }
 
  
 /// This function needs to be implemented in the derived problem:
 /// Return a pointer to a (deep) copy of the problem.
 /// The problem needs to be fully functional
 /// with all equations numbered etc.
 virtual MGProblem* make_copy()=0;
 
 
 /// \short Pre-smoother: Perform max_iter smoothing steps for linear 
 /// system Ax=b with current rhs vector, b, starting with current solution 
 /// vector, x. Return residual vector r=b-Ax. Uses the default smoother (set
 /// in the MGProblem constructor) which can be overloaded for specific 
 /// problem.  
 virtual void pre_smooth(const unsigned& max_iter, Vector<double>& residual);
 

 /// \short Post-smoother: Perform max_iter smoothing steps for linear 
 /// system Ax=b with current rhs vector, b, starting with current solution 
 /// vector, x. Uses the default smoother (set
 /// in the MGProblem constructor) which can be overloaded for specific 
 /// problem.  
 virtual void post_smooth(const unsigned& max_iter);
 
 /// \short Return norm of residual r=b-Ax
 virtual double residual_norm();

 /// \short Return norm of residual r=b-Ax and residual vector itself
 virtual double residual_norm(Vector<double>& residual);
 
 /// \short Direct solver for linear system Ax=b
 /// with current rhs vector, b. Result gets stored locally
 /// in the MGProblem's solution vector, x.
 virtual void direct_solve();
 


 /// \short Restrict residual (computed on current MG level) to
 /// next coarser mesh and stick it into the coarse mesh rhs vector
 /// using the transpose of the interpolation matrix P^T
 void restrict_full_weighting(const Vector<double>& residual);
 
 /// \short Restrict residual (computed on current MG level) to
 /// next coarser mesh and stick it into the coarse mesh rhs vector
 /// using direct restriction
 void restrict_injection(const Vector<double>& residual);
 
 /// \short Restrict residual (computed on current MG level) to
 /// next coarser mesh and stick it into the coarse mesh rhs vector
 /// using direct restriction multiplied by a variable
 /// the sum of the row in the P^T
 void restrict_sum_injection(const Vector<double>& residual);

 /// \short Interpolate solution at current level onto 
 /// next finer mesh and correct the solution x at that level
 void interpolate_and_correct();

 /// \short Plot current rhs vector (assuming we're dealing with
 /// scalar nodal data. Otherwise I don't know how to implement 
 /// this...)
 void plot_rhs(const std::string& filename);

 /// \short Plot current mg solution vector (assuming we're dealing 
 /// with
 /// scalar nodal data. Otherwise I don't know how to implement 
 /// this...)
 void plot_x(const std::string& filename);
 
 /// \short Setup multigrid at this level: Create system matrix (or whatever
 /// else
 /// is needed to perform smoothing/direct solve), and
 /// resize and initialise the rhs and solution vectors. 
 /// Pass level in overall hierarchy and pointer
 /// to counter for number of v-cycles (for doc)
 virtual void setup_mg(const unsigned& level, 
                       unsigned* v_cycle_counter_pt);
 
 /// Pointer to coarser mg level  (NULL if we're at the coarsest 
 /// level)
 MGProblem*& next_coarser_mg_level_pt()
  {
   return Next_coarser_mg_level_pt;
  }
 
 /// \short Pointer to coarser mg level (NULL if we're at the 
 /// coarsest level). Const version
 MGProblem* next_coarser_mg_level_pt() const
  {
   return Next_coarser_mg_level_pt;
  }
 
 
 /// Pointer to finer mg level  (NULL if we're at the finest level)
 MGProblem*& next_finer_mg_level_pt()
  {
   return Next_finer_mg_level_pt;
  }
 

 /// \short Pointer to finer mg level  (NULL if we're at the
 /// finest level). Const version.
 MGProblem* next_finer_mg_level_pt() const
  {
   return Next_finer_mg_level_pt;
  }
 
 /// Access to i-th entry in MG solution vector
 double& x_mg(const unsigned& i)
  {
   return X_mg[i];
  }
 
 
 /// Access to i-th entry in MG rhs vector
 double& rhs_mg(const unsigned& i)
  {
   return Rhs_mg[i];
  }


 // hierher
/*    /// Inserts the i-th entry in MG restrict vector */
/*    void restrict_set(int& jj,int& ii) */
/*    { */
/*     restrict_map[jj]=ii; */
/*    } */

/*    /// Access to i-th entry in restrict vector */
/*    unsigned& restrict_get(const unsigned& i) */
/*     { */
/*      return restrict_map[i]; */
/*     } */

/*    /// Resizes the restrict vector to i */
/*    void restrict_resize(unsigned& i) */
/*    { */
/*     restrict_map.resize(i); */
/*    } */

 
 /// \short Builds a  CRDoubleMatrix that is used to interpolate the 
 /// residual between levels. The transpose can be used as the full 
 /// weighting restriction. 
 /// hierher: Is this really needed or can we manipulate
 ///          the matrix directly?
 void interpolation_matrix_set(Vector<double>& value,
                               Vector<int>& col_index,
                               Vector<int>& row_st,
                               unsigned& size)
  {
   //ALH: Assumed matrix is square (pass row x col at end)
   Interpolation_matrix.build(value, col_index, row_st, size,size);
  }
 
 /// Access to the interpolation matrix
 CRDoubleMatrix& interpolation_matrix()
  {
   return Interpolation_matrix;
  }
 

 /// \short Return a  pointer to the smoother
 Smoother*& pre_smoother_pt()
  {
   return Pre_Smoother_pt;
  }



 /// \short Return a  pointer to the smoother (const version)
 Smoother* pre_smoother_pt() const
  {
   return Pre_Smoother_pt;
  }

 /// \short Return a  pointer to the smoother 
  Smoother*& post_smoother_pt()
  {
   return Post_Smoother_pt;
  }

 /// \short Return a  pointer to the smoother (const version)
 Smoother* post_smoother_pt() const
  {
   return Post_Smoother_pt;
  }

  private:
 
 /// \short Label to store which level we are in overall hierarchy
 /// (mainly (only?) used for output)
 unsigned MG_level;
 
 /// \short Pointer to coarser level problem (NULL if we're at the coarsest 
 /// level)
 MGProblem* Next_coarser_mg_level_pt;
 
 /// Pointer to finer level problem (NULL if we're at the finest level)
 MGProblem* Next_finer_mg_level_pt;
 
 /// RHS vector
 Vector<double> Rhs_mg;
 
 /// Solution vector
 Vector<double> X_mg;
 
 /// System matrix stored as a condensed row matrix
 CRDoubleMatrix Matrix_mg;
 
 /// Pointer to the smoother class
 Smoother* Pre_Smoother_pt;
 
 /// Pointer to the smoother class
 Smoother* Post_Smoother_pt;

 /// Pointer to counter for v-cycles (used for doc)
 unsigned* V_cycle_counter_pt;
 
 /// Interpolation matrix
 CRDoubleMatrix Interpolation_matrix;
 
 //restrivtion mapping
 // hierher Vector<unsigned> Restrict_map; // needed?
 
 };




///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=====================================================
/// MG solver
//=====================================================
template<unsigned DIM>
class MGSolver : public IterativeLinearSolver
{
  
  public:
 

 /// Constructor: Setup  default values for number of V-cycles
 /// and pre- and post-smoothing steps. Use full weighting
 /// for injection. 
 MGSolver() : Nvcycle(20), Npre_smooth(2), Npost_smooth(2),
  V_cycle_counter_pt(new unsigned(0)), Restrict_flag(3)
  {
   // Set the tolerance for the iteration -- defined in base class
   Tolerance=0.00001;

   // Note: Possible values for Restrict_flag are: hierher: enum
   // 1 : sum injection 
   // 2 : injection
   // 3 : full weighting
  }
   
 /// Destructor: Kill coarser multigrid problems that were created in 
 /// setup() (if any).
 ~MGSolver() 
  {
   unsigned n_level=nlevel();
   
   // Start from level 1 to make sure we don't wipe the original
   // problem
   for (unsigned i=1;i<n_level;i++)
    {
     delete MG_level[i];
     MG_level[i]=0;
    }
   delete V_cycle_counter_pt;
  }
   
   
 /// Access function for the number of levels in MG hierarchy
 unsigned nlevel() {return MG_level.size();}
 
 
 /// Setup the MG hierarchy and return the number of levels created
 unsigned setup(MGProblem* problem_pt);
 
 /// \short Given the son_type of an element and a local node
 /// number j in that element with nnode_1d nodes per coordinate
 /// direction, return the local coordinate s in its
 /// father element. 
 void level_up_local_coord_of_node(const unsigned& j,
                                   const unsigned& son_type,
                                   const unsigned& nnode_1d,
                                   Vector<double>& s);
 
 /// Do the actual solve -- this implements the pure virtual
 /// function in the LinearSolver base class
 void solve(Problem* const& problem_pt, Vector<double>& result);
 
 /// Number of iterations taken 
 unsigned iterations()
  {
   return *V_cycle_counter_pt;
  }



  private:
 
 /// Vector containing pointers to problems in hierarchy
 Vector<MGProblem*> MG_level;
 
 /// Max. number of V-cycles 
 unsigned Nvcycle;
 
 /// Convergence tolerance
 //double Tolerance; hierher
 
 /// Number of pre-smoothing steps
 unsigned Npre_smooth;
 
 /// Number of post-smoothing steps
 unsigned Npost_smooth;
 
 /// Pointer to counter for v-cycles (used for doc at various levels)
 unsigned* V_cycle_counter_pt;
 
 /// By constructor defult restriction is full weighting
 unsigned Restrict_flag;
 
 };//mgsolver






//=========================================================================
/// Gauss Seidel templated by matrix type.  This Gauss Seidel method
/// uses the same structure as the super Gauss Seidel class but uses 
/// the upper elements of the matrix when perorming an iteration.
/// this is manly used with the super Gauss Seidel method to 
/// keep the matrix symetric
//=========================================================================
 template<typename MATRIX>
 class UpperGaussSeidel : public Smoother, public IterativeLinearSolver,
 public Preconditioner
 {
 
  public:
 
 /// Empty constructor
 UpperGaussSeidel(){};
 
 /// Empty destructor
 ~UpperGaussSeidel(){};

 /// Broken copy constructor
 UpperGaussSeidel(const UpperGaussSeidel&) 
  { 
   BrokenCopy::broken_copy("UpperGaussSeidel");
  } 
 
 /// Broken assignment operator
 void operator=(const UpperGaussSeidel&) 
  {
   BrokenCopy::broken_assign("UpperGaussSeidel");
  }

 /// Setup: Pass pointer to the matrix and store in cast form
 void smoother_setup(DoubleMatrixBase* matrix_pt)
  {
   Matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  }  

 /// Smoother performs  nsmooth Gauss Seidel iterations on the
 /// system A e = r
 void smoother_solve(const unsigned &nsmooth, 
                     const Vector<double>& r,
                     Vector<double> &e)
  {
   GS_upper_iterations(nsmooth, r, e);
  }
 

/// Use Gauss Seidel iteration as an IterativeLinarSolver: This
 /// obtains the Jacobian matrix J and the residual vector r
 /// (needed for the Newton method) from the problem's get_jacobian
 /// function and returns the result of Jx=r.
 void solve(Problem* const &problem_pt, Vector<double> &result)
  {
   
   //Find # of degrees of freedom (variables)
   unsigned n_dof = problem_pt->ndof();
 
   //Get the jacobian and residual of the nonlinear problem
   MATRIX jacobian;
  
   Vector<double> f(n_dof);
   problem_pt->get_jacobian(f,jacobian);
    
   // Initial guess is zero so the residual is equal to the RHS
   Vector<double> x(n_dof,0.0);
   Vector<double> local_residual(n_dof);
   for(unsigned i=0;i<n_dof;i++)
    {   
     local_residual[i]=f[i];
    }
 
   //Setup
 
  smoother_setup(&jacobian);
  
   // Solve and copy result
   GS_upper_iterations(Max_iter,local_residual,x);
   result=x;
  
  }

 /// Number of iterations taken 
 unsigned iterations()
  {
   return Iterations;
  }
   
  private:
 
 ///  \short This is where the actual work is done -- different
 /// implementations for different matrix types.
 void GS_upper_iterations(const unsigned &nsmooth, const Vector<double>& r,
                    Vector<double> &e);
 
  /// Pointer to the matrix
  MATRIX* Matrix_pt;

  /// Number of iterations taken
  unsigned Iterations; 

 };//Gauss-Seidel upper





//=========================================================================
/// Jacobi "solver" templated by matrix type. The "solver"
/// exists in many different incarnations: Its an IterativeLinearSolver,
/// and a Smoother, all of which use the
/// same basic iteration.
//// hierher: ToDo Move into iterative linear solver
//=========================================================================
template<typename MATRIX>
class Jacobi : public Smoother, public IterativeLinearSolver
{
 
  public:
 
 /// Emtpy constructor
 Jacobi(){};
 
 /// Empty destructor
 ~Jacobi(){};

 /// Broken copy constructor
 Jacobi(const Jacobi&) 
  { 
   BrokenCopy::broken_copy("Jacobi");
  } 
 
 /// Broken assignment operator
 void operator=(const Jacobi&) 
  {
   BrokenCopy::broken_assign("Jacobi");
  }
 

 /// Setup: Pass pointer to the matrix and store in cast form
 void smoother_setup(DoubleMatrixBase* matrix_pt)
  {
   Matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  }
 
 /// Smoother performs  nsmooth Jacobi iterations on the
 /// system A e = r
 void smoother_solve(const unsigned &nsmooth, 
                     const Vector<double>& r,
                     Vector<double> &e)
  {
   jacobi_iterations(nsmooth, r, e);
  }
  

 /// Use Jacobi iteration as an IterativeLinarSolver: This
 /// obtains the Jacobian matrix J and the residual vector r
 /// (needed for the Newton method) from the problem's get_jacobian
 /// function and returns the result of Jx=r.
 void solve(Problem* const &problem_pt, Vector<double> &result)
  {
   //Find # of degrees of freedom (variables)
   unsigned n_dof = problem_pt->ndof();
   
   //Get the jacobian and residual of the nonlinear problem
   MATRIX jacobian;
     
   Vector<double> f(n_dof);
   problem_pt->get_jacobian(f,jacobian);
    
   // Initial guess is zero so the residual is equal to the RHS
   Vector<double> x(n_dof,0.0);
   Vector<double> local_residual(n_dof);
   for(unsigned i=0;i<n_dof;i++)
    {   
     local_residual[i]=f[i];
    }
   
   // Setup
   smoother_setup(&jacobian);
    
   // Solve and copy back
   jacobi_iterations(Max_iter,local_residual,x);
   result=x;
    
  }
   
  /// Number of iterations taken 
  unsigned iterations()
  {
   return Iterations;
  }

  private:
   
  /// \short This is where the actual work is done -- different
  /// implementations for different matrix types.
  void jacobi_iterations(const unsigned &nsmooth, 
                         const Vector<double> &r,
                         Vector<double> &e);
  

  private:
  
  /// Pointer to the matrix
  MATRIX* Matrix_pt;

  /// Number of iterations taken
  unsigned Iterations;
  
 };



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////




//=========================================================================
//ILU(0) class 
// hierher: This is a verbatim copy of Richard's ILUZeroPreconditioner.
///         ToDo: merge!
//=========================================================================


//========================================================================
/// ILU(0) Preconditioner/smoother
//========================================================================
 template <typename MATRIX> 
 class ILUZero : public Preconditioner, public Smoother
 {
 };



//========================================================================
/// ILU(0) Preconditioner for matrices of CRDoubleMatrix format
//========================================================================
template <> 
class ILUZero<CRDoubleMatrix> : public Preconditioner, public Smoother
{
 
 public :
  
  ///Constructor: Default reduction flag to off
  ILUZero() : Reduction_flag(false), Alpha(0.0)
  { }
 
 ///Constructor: Specify flag for reducing matrix and relative
 /// drop tolerance for matrix reduction
 ILUZero(const bool& reduction_flag, const double& alpha) :
  Reduction_flag(reduction_flag), Alpha(alpha)
  {
#ifdef PARANOID
   // Check range of alpha! hierher
#endif
  }
 
 /// Broken copy constructor
 ILUZero(const ILUZero&) 
  { 
   BrokenCopy::broken_copy("ILUZero");
  } 
 
 /// Broken assignment operator
 void operator=(const ILUZero&) 
  {
   BrokenCopy::broken_assign("ILUZero");
  }
 
 ///Destructor (empty)
 ~ILUZero() {}
 
 
 /// \short Setup the preconditioner -- pass the pointer to the matrix to it.
 void preconditioner_setup(DoubleMatrixBase* matrix_pt)
  {
   ILU_setup(matrix_pt);
  }
 
 /// Apply preconditioner to r
 void preconditioner_solve(const Vector<double>&r, Vector<double> &z)
  {
   ILU_solve(r,z);
  }
 
 
 /// \short Setup the smoother -- pass the pointer to the matrix to it.
 void smoother_setup(DoubleMatrixBase* matrix_pt)
  {
   // Reduce matrix first then setup ILU decomposition of reduced matrix
   if (Reduction_flag)
    {
     CRDoubleMatrix ILU_reduced_matrix;
     dynamic_cast<CRDoubleMatrix *>(matrix_pt)->
      matrix_reduction(Alpha,ILU_reduced_matrix);
    
     ILU_setup(&ILU_reduced_matrix);   
    }
   else
    {
     ILU_setup(matrix_pt);
    }
 
   // Store the pointer to the main matrix
   ILU_matrix_pt=dynamic_cast<CRDoubleMatrix *>(matrix_pt);
  }


  /// Smoother performs  nsmooth iterations on the
  /// system A e = r: hierher Glyn: explain what's going on.
  void smoother_solve(const unsigned &nsmooth,
                      const Vector<double> &r,
                      Vector<double> &e);

   private:

  /// Solve  A e = r by performinig the back-substitutioon the
  /// incomplete LU decomposition. 
  void ILU_solve(const Vector<double> &r,
                 Vector<double> &e);
 
  /// Setup: Compute ILU factors and stores them
  void ILU_setup(DoubleMatrixBase* matrix_pt);
 
  /// Row start for upper triangular matrix 
  Vector<unsigned> U_row_start;

  /// Column index for upper triangular matrix 
  Vector<unsigned> U_column_index;

  /// Values for upper triangular matrix 
  Vector<double> U_value;
 
  /// Row start for lower triangular matrix 
  Vector<unsigned> L_row_start;

  /// Column index for lower triangular matrix 
  Vector<unsigned> L_column_index;

  /// Values for lower triangular matrix 
  Vector<double> L_value;

  /// Flag to turn the reduction on or off 
  bool Reduction_flag;

  /// Pointer to the jacobian matrix
  CRDoubleMatrix* ILU_matrix_pt;

  /// Alpha \in [0,1] is used for the reduction proccess only.
  /// 1 : throw all non diagonal small values away
  /// 0 : results in the same matrix as the jacobian 
  double Alpha;

 

 };

}

#endif
