//Header file for refineable QSpectralHelmholtzElement elements

#ifndef OOMPH_REFINEABLE_SPECTRAL_HELMHOLTZ_ELEMENTS_HEADER
#define OOMPH_REFINEABLE_SPECTRAL_HELMHOLTZ_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//oomph-lib headers
#include "refineable_helmholtz_elements.h"
#include "../generic/refineable_quad_spectral_element.h"
#include "../generic/refineable_brick_spectral_element.h"

namespace oomph
{


//======================================================================
/// Refineable version of 2D QSpectralHelmholtzElement elements
///
///
//======================================================================
template <unsigned DIM, unsigned NNODE_1D>
class RefineableQSpectralHelmholtzElement : 
           public QSpectralHelmholtzElement<DIM,NNODE_1D>,
           public virtual RefineableHelmholtzEquations<DIM>,
           public virtual RefineableQSpectralElement<DIM>
{
  public:

 /// \short Constructor: Pass refinement level to refineable quad element
 /// (default 0 = root)
  RefineableQSpectralHelmholtzElement() : 
   RefineableElement(),
   RefineableHelmholtzEquations<DIM>(),
   RefineableQElement<DIM>(),
   QSpectralHelmholtzElement<DIM,NNODE_1D>()
   {} 


 /// Broken copy constructor
 RefineableQSpectralHelmholtzElement(
  const RefineableQSpectralHelmholtzElement<DIM,NNODE_1D> & dummy) 
  { 
   BrokenCopy::broken_copy("RefineableQuadHelmholtzElement");
  } 
 
 /// Broken assignment operator
 void operator=(const RefineableQSpectralHelmholtzElement<DIM,NNODE_1D>&) 
  {
   BrokenCopy::broken_assign("RefineableQuadHelmholtzElement");
  }
 
 /// Number of continuously interpolated values: 1
 unsigned ncont_interpolated_values() const {return 1;}
 
 /// \short Number of vertex nodes in the element
 unsigned nvertex_node() const
  {return QSpectralHelmholtzElement<DIM,NNODE_1D>::nvertex_node();}
 
 /// \short Pointer to the j-th vertex node in the element
 Node* vertex_node_pt(const unsigned& j) const
  {return QSpectralHelmholtzElement<DIM,NNODE_1D>::vertex_node_pt(j);}

 /// \short Use RefineableElement::assign_all_generic_local_eqn_numbers
 ///        (this may need to be altered...?)
/*  virtual inline void assign_all_generic_local_eqn_numbers() */
/*   { */
/*    RefineableElement::assign_all_generic_local_eqn_numbers(); */
/*   } */

 /// \short Order of recovery shape functions for Z2 error estimation:
 /// Same order as shape functions.
 unsigned nrecovery_order() 
  {
   if(NNODE_1D < 4) {return (NNODE_1D-1);}
   else {return 3;}
  }

 ///  \short Perform additional hanging node procedures for variables
 /// that are not interpolated by all nodes. Empty.
 void further_setup_hanging_nodes(){}

};


//=======================================================================
/// Face geometry for the RefineableQuadHelmholtzElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<RefineableQSpectralHelmholtzElement<DIM,NNODE_1D> >: 
 public virtual QSpectralElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : QSpectralElement<DIM-1,NNODE_1D>() {}

};

}


#endif

