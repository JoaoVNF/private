//Header file for Helmholtz elements
#ifndef OOMPH_HELMHOLTZ_ELEMENTS_HEADER
#define OOMPH_HELMHOLTZ_ELEMENTS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/Qelements.h"
#include "../generic/oomph_utilities.h"
#include "../generic/element_with_external_element.h"

namespace oomph
{

//=============================================================
/// A class for all isoparametric elements that solve the 
/// Helmholtz equations.
/// \f[ 
/// \frac{\partial^2 u}{\partial x_i^2} = u + f(x_j)
/// \f] 
/// This contains the generic maths. Shape functions, geometric
/// mapping etc. must get implemented in derived class.
//=============================================================
template <unsigned DIM>
class HelmholtzEquations : public virtual ElementWithExternalElement
{

public:

 /// \short Function pointer to source function fct(x,f(x)) -- 
 /// x is a Vector! 
 typedef void (*HelmholtzSourceFctPt)(const Vector<double>& x, double& f);
 

 /// Constructor (must initialise the Source_fct_pt to null)
 HelmholtzEquations() : Source_fct_pt(0) 
  {
   initialise_external_element_storage();
  }
 
 /// Broken copy constructor
 HelmholtzEquations(const HelmholtzEquations& dummy) 
  { 
   BrokenCopy::broken_copy("HelmholtzEquations");
  } 
 
 /// Broken assignment operator
 void operator=(const HelmholtzEquations&) 
  {
   BrokenCopy::broken_assign("HelmholtzEquations");
  }

 /// \short Return the index at which the unknown value
 /// is stored. The default value, 0, is appropriate for single-physics
 /// problems, when there is only one variable, the value that satisfies
 /// the helmholtz equation. 
 /// In derived multi-physics elements, this function should be overloaded
 /// to reflect the chosen storage scheme. Note that these equations require
 /// that the unknown is always stored at the same index at each node.
 virtual inline unsigned u_index_helmholtz() const {return 0;}

 /// Output with default number of plot points
 void output(std::ostream &outfile) 
  {
   const unsigned n_plot=5;
   output(outfile,n_plot);
  }

 /// \short Output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot);

 /// C_style output with default number of plot points
 void output(FILE* file_pt)
  {
   const unsigned n_plot=5;
   output(file_pt,n_plot);
  }

 /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot);

 /// Output exact soln: x,y,u_exact or x,y,z,u_exact at n_plot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &n_plot, 
                 FiniteElement::SteadyExactSolutionFctPt exact_soln_pt);

 /// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at 
 /// n_plot^DIM plot points (dummy time-dependent version to 
 /// keep intel compiler happy)
 virtual void output_fct(std::ostream &outfile, const unsigned &n_plot,
                         const double& time, 
                         FiniteElement::UnsteadyExactSolutionFctPt 
                         exact_soln_pt)
  {
   throw OomphLibError(
    "There is no time-dependent output_fct() for Helmholtz elements ",
    "HelmholtzEquations<DIM>::output_fct()",
    OOMPH_EXCEPTION_LOCATION);
  }


 /// Get error against and norm of exact solution
 void compute_error(std::ostream &outfile, 
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                    double& error, double& norm);


 /// Dummy, time dependent error checker
 void compute_error(std::ostream &outfile, 
                    FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                    const double& time, double& error, double& norm)
  {
   throw OomphLibError(
    "There is no time-dependent compute_error() for Helmholtz elements",
    "HelmholtzEquations<DIM>::compute_error()",
    OOMPH_EXCEPTION_LOCATION);
  }

 /// Access function: Pointer to source function
 HelmholtzSourceFctPt& source_fct_pt() {return Source_fct_pt;}

 /// Access function: Pointer to source function. Const version
 HelmholtzSourceFctPt source_fct_pt() const {return Source_fct_pt;}


 /// Get source term at (Eulerian) position x. This function is
 /// virtual to allow overloading in multi-physics problems where
 /// the strength of the source function might be determined by
 /// another system of equations.
 inline virtual void get_source_helmholtz(const Vector<double>& x, 
                                        double& source) const
  {
   //If no source function has been set, return zero
   if(Source_fct_pt==0) {source = 0.0;}
   else
    {
     // Get source strength
     (*Source_fct_pt)(x,source);
    }
  }



 /// Get flux: flux[i] = du/dx_i
 void get_flux(const Vector<double>& s, Vector<double>& flux) const
  {
   //Find out how many nodes there are in the element
   const unsigned n_node = nnode();

   //Get the index at which the unknown is stored
   const unsigned u_nodal_index = u_index_helmholtz();

   //Set up memory for the shape and test functions
   Shape psi(n_node);
   DShape dpsidx(n_node,DIM);
 
   //Call the derivatives of the shape and test functions
   dshape_eulerian(s,psi,dpsidx);
     
   //Initialise to zero
   for(unsigned j=0;j<DIM;j++)
    {
     flux[j] = 0.0;
    }
   
   // Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
    {
     //Loop over derivative directions
     for(unsigned j=0;j<DIM;j++)
      {                               
       flux[j] += this->nodal_value(l,u_nodal_index)*dpsidx(l,j);
      }
    }
  }


 /// Add the element's contribution to its residual vector (wrapper)
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix argument
   fill_in_generic_residual_contribution_helmholtz(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }

/*  void fill_in_contribution_to_jacobian(Vector<double> &residuals, */
/*                                    DenseMatrix<double> &jacobian) */
/*   { */
/*    //Call the generic routine with the flag set to 1 */
/*    fill_in_generic_residual_contribution_helmholtz(residuals,jacobian,1); */
/*    // Call the base class fill_in... function */
/* //   FiniteElement::fill_in_contribution_to_jacobian(residuals,jacobian); */
/*    // fill in the jacobian from the "source data" */
/* //   fill_in_jacobian_from_external_source_by_fd(residuals,jacobian); */

/* //   oomph_info << "after call to fill_in_jacobian_source..." << std::endl; */
/*   } */
 


 ///bla hierher : move back into FE base class when done
 /// and when container for "source data" has been moved there.
 /// [Hang on though, there isn't a container for "source data"...
 ///  ... there are "source elements", but not data... ?]
 /* void fill_in_jacobian_from_external_source_by_fd */
/*   (Vector<double> &residuals,DenseMatrix<double> &jacobian) */
/*  { */
/*   // There will always be a source element for each integration */
/*   // point on each element; if not, the code will have hopefully */
/*   // barked before this point anyway, but perhaps this is the correct */
/*   // place to put the error? */

/*   //Find the number of dofs in the element */
/*   const unsigned n_dof = ndof(); */

/*   oomph_info << "n_dof (element) = " << n_dof << std::endl; */

/*   //Create newres vector */
/*   Vector<double> newres(n_dof); */

/*   //Integer storage for local unknown */
/*   int local_unknown=0; */
  
/*   //Use the default finite difference step */
/*   const double fd_step = Default_fd_jacobian_step; */

/*   //Loop over integration points (which store source data) */
/*   const unsigned n_intpt = integral_pt()->nweight(); */

/*   oomph_info << "n_intpt=" << n_intpt << std::endl; */

/*   //Loop over the integration points */
/*   for (unsigned ipt=0; ipt<n_intpt; ipt++) */
/*    { */
/*     oomph_info << "ipt=" << ipt << std::endl; */

/*     //Get the source element for this integration point */
/*     HelmholtzEquations<DIM>* source_el_pt=other_el_pt(ipt); */

/*     //hierher Perhaps shouting at this point if there is no */
/*     //        source element for this integration point would */
/*     //        be a good idea, rather than earlier? ... CHECK */

/*     //Loop over the nodes of this element */
/*     unsigned n_node = source_el_pt->nnode(); */
/*     for (unsigned n=0; n<n_node; n++) */
/*      { */
/*       //Get the number of values  */
/*       unsigned n_value = source_el_pt->node_pt(n)->nvalue(); */

/*       //Loop over the number of values */
/*       for(unsigned j=0;j<n_value;j++) */
/*        { */
/*         //Get the local equation number */
/*         local_unknown = source_el_pt->nodal_local_eqn(n,j); */
/*         //If it's not pinned */
/*         if(local_unknown >= 0) */
/*          { */
/*           //Get a pointer to the "source" data value */
/*           double *value_pt = source_el_pt->node_pt(n)->value_pt(j); */
        
/*           //Save the old value of the "source" data */
/*           double old_var = *value_pt; */
         
/*           //Increment the value of the "source" data */
/*           *value_pt += fd_step; */
       
/*           //Calculate the new residuals */
/*           get_residuals(newres); */
       
/*           //Do finite differences */
/*           for(unsigned m=0;m<n_dof;m++) */
/*            { */
/*             double sum = (newres[m] - residuals[m])/fd_step; */
/*             //Stick the entry into the Jacobian matrix */
/*             jacobian(m,local_unknown) = sum; */
/*            } */
        
/*           //Reset the "source" data */
/*           *value_pt = old_var; */
/*          } */
/*        } */
/*      } */
/*     oomph_info << "ipt=" << ipt << std::endl; */
/*    } */
/*   oomph_info << "end of fill_in_jacobian_from_external_source..." << std::endl; */
/*  } */






 /// \short Return FE representation of function value u_helmholtz(s) 
 /// at local coordinate s
 inline double interpolated_u_helmholtz(const Vector<double> &s) const
  {
   //Find number of nodes
   const unsigned n_node = nnode();

   //Get the index at which the helmholtz unknown is stored
   const unsigned u_nodal_index = u_index_helmholtz();
   
   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of u
   double interpolated_u = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_u += this->nodal_value(l,u_nodal_index)*psi[l];
    }

   return(interpolated_u);
  }

 /// \short Self-test: Return 0 for OK
 unsigned self_test();

protected:

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_helmholtz(const Vector<double> &s, 
                                                  Shape &psi, 
                                                  DShape &dpsidx, Shape &test, 
                                                  DShape &dtestdx) const=0;
 

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_at_knot_helmholtz(const unsigned &ipt, 
                                                          Shape &psi, 
                                                          DShape &dpsidx,
                                                          Shape &test, 
                                                          DShape &dtestdx) 
  const=0;

 /// \short Compute element residual Vector only (if flag=and/or element 
 /// Jacobian matrix 
 virtual void fill_in_generic_residual_contribution_helmholtz(
  Vector<double> &residuals, DenseMatrix<double> &jacobian, 
  unsigned flag); 
 
 /// Pointer to source function:
 HelmholtzSourceFctPt Source_fct_pt;

/*  /// Vector of pointers to other elements that provide a  */
/*  /// contribution to the source for the current element */
/*  /// at each integration point of the current element */
/*  Vector<HelmholtzEquations<DIM>* > Other_el_pt; */

/*   private: */

/*  /// Vector of Vector of local coords for other elements */
/*  /// at each integration point of the current element */
/*  Vector<Vector<double> > Other_el_local_coord; */
 
};






///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//======================================================================
/// QHelmholtzElement elements are linear/quadrilateral/brick-shaped 
/// Helmholtz elements with isoparametric interpolation for the function.
//======================================================================
template <unsigned DIM, unsigned NNODE_1D>
 class QHelmholtzElement : public virtual QElement<DIM,NNODE_1D>,
 public virtual HelmholtzEquations<DIM>
{

private:

 /// \short Static int that holds the number of variables at 
 /// nodes: always the same
 static const unsigned Initial_Nvalue;
 
  public:


 ///\short  Constructor: Call constructors for QElement, 
 /// Helmholtz equations
 QHelmholtzElement() : QElement<DIM,NNODE_1D>(), HelmholtzEquations<DIM>()
  {
// add function to set storage for "other" element here; check the number
// of integration points has been set already
  }
 
 /// Broken copy constructor
 QHelmholtzElement(const QHelmholtzElement<DIM,NNODE_1D>& dummy) 
  { 
   BrokenCopy::broken_copy("QHelmholtzElement");
  } 
 
 /// Broken assignment operator
 void operator=(const QHelmholtzElement<DIM,NNODE_1D>&) 
  {
   BrokenCopy::broken_assign("QHelmholtzElement");
  }


 /// \short  Required  # of `values' (pinned or dofs) 
 /// at node n
 inline unsigned required_nvalue(const unsigned &n) const 
  {return Initial_Nvalue;}

 /// \short Output function:  
 ///  x,y,u   or    x,y,z,u
 void output(std::ostream &outfile)
  {HelmholtzEquations<DIM>::output(outfile);}


 ///  \short Output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot)
  {HelmholtzEquations<DIM>::output(outfile,n_plot);}


 /// \short C-style output function:  
 ///  x,y,u   or    x,y,z,u
 void output(FILE* file_pt)
  {HelmholtzEquations<DIM>::output(file_pt);}


 ///  \short C-style output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot)
  {HelmholtzEquations<DIM>::output(file_pt,n_plot);}


 /// \short Output function for an exact solution:
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 FiniteElement::SteadyExactSolutionFctPt exact_soln_pt)
  {HelmholtzEquations<DIM>::output_fct(outfile,n_plot,exact_soln_pt);}



 /// \short Output function for a time-dependent exact solution.
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 /// (Calls the steady version)
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 const double& time,
                 FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {HelmholtzEquations<DIM>::output_fct(outfile,n_plot,time,exact_soln_pt);}


 /// \short global position vector at local s (return interpolated_x)
 void position(const Vector<double>& s, Vector<double>& r) const
  {
   // Get the position vector using interpolated_x
   this->interpolated_x(s,r);
  }

protected:

/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
 inline double dshape_and_dtest_eulerian_helmholtz(
  const Vector<double> &s, Shape &psi, DShape &dpsidx, 
  Shape &test, DShape &dtestdx) const;


 /// \short Shape, test functions & derivs. w.r.t. to global coords. at
 /// integration point ipt. Return Jacobian.
 inline double dshape_and_dtest_eulerian_at_knot_helmholtz(const unsigned& ipt,
                                                         Shape &psi, 
                                                         DShape &dpsidx, 
                                                         Shape &test,
                                                         DShape &dtestdx) 
  const;

};




//Inline functions:


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned DIM, unsigned NNODE_1D>
 double QHelmholtzElement<DIM,NNODE_1D>::dshape_and_dtest_eulerian_helmholtz(
  const Vector<double> &s,
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 const double J = this->dshape_eulerian(s,psi,dpsidx);

 //Set the test functions equal to the shape functions
 test = psi;
 dtestdx= dpsidx;
 
 //Return the jacobian
 return J;
}




//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned DIM, unsigned NNODE_1D>
double QHelmholtzElement<DIM,NNODE_1D>::
 dshape_and_dtest_eulerian_at_knot_helmholtz(
  const unsigned &ipt,
  Shape &psi, 
  DShape &dpsidx,
  Shape &test, 
  DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 const double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

 //Set the pointers of the test functions
 test = psi;
 dtestdx = dpsidx;

 //Return the jacobian
 return J;
}


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//=======================================================================
/// Face geometry for the QHelmholtzElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<QHelmholtzElement<DIM,NNODE_1D> >: 
 public virtual QElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

};

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 1D QHelmholtzElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<QHelmholtzElement<1,NNODE_1D> >: 
 public virtual PointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : PointElement() {}

};



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


}

#endif
