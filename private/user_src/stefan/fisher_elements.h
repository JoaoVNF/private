//Header file for Fisher elements


#ifndef OOMPH_FISHER_ELEMENTS_HEADER
#define OOMPH_FISHER_ELEMENTS_HEADER

									       
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
 #include <oomph-lib-config.h>
#endif

//Standard libray headers
#include<fstream>
#include<map>


//OOMPH-LIB headers
#include "../generic/nodes.h"
#include "../generic/Qelements.h"
#include "../generic/oomph_utilities.h"



namespace oomph
{




//=============================================================
/// A class for all isoparametric elements that solve the 
/// Fisher equations.
/// \f[ 
/// \frac{\partial^2 u}{\partial x_i^2} + F (u - u^2) =
/// \frac{\partial u}{\partial t}+f(t,x_j)
/// \f] 
/// F is simply a factor (which defaults to 1.0) that allows
/// switching to the unsteady heat equation for validation 
/// purposes
/// This contains the generic maths. Shape functions, geometric
/// mapping etc. must get implemented in derived class.
/// Note that this class assumes an isoparametric formulation, i.e. that
/// the scalar unknown is interpolated using the same shape funcitons
/// as the position.
//=============================================================
template <unsigned DIM>
class FisherEquations : public virtual FiniteElement
{

public:

 /// \short Function pointer to source function fct(x,f(x)) -- 
 /// x is a Vector! 
 typedef void (*FisherSourceFctPt)(const double& time,
                                         const Vector<double>& x,
                                         double& u);


 /// Constructor (must initialise the Source_fct_pt to null
 /// and set Fisher factor to its default (1).
 FisherEquations() : Source_fct_pt(0)
  {
   Fisher_factor_pt = &Default_Fisher_Factor_Value;
  }
 

 /// Broken copy constructor
 FisherEquations(const FisherEquations& dummy) 
  { 
   BrokenCopy::broken_copy("FisherEquations");
  } 
 
 /// Broken assignment operator
 void operator=(const FisherEquations&) 
  {
   BrokenCopy::broken_assign("FisherEquations");
  }


 /// Fisher factor: Control strength of Fisher term u - u^2
 const double& fisher_factor() const {return *Fisher_factor_pt;}

 /// Pointer to Fisher factor 
 double*& fisher_factor_pt() {return Fisher_factor_pt;}

 /// \short Access function: Nodal function value at local node n
 /// Uses suitably interpolated value for hanging nodes.
 /// Default is to assume that the unknown is the first (only) stored
 /// value at the nodes.
 virtual inline double u(const unsigned& n) const 
  {return nodal_value(n,0);}


 /// \short Access function: Nodal function value at local node n,
 /// at t-th history level. Uses suitably interpolated value for hanging nodes.
 virtual inline double u(const unsigned& t, const unsigned& n) const 
  {return nodal_value(t,n,0);}

 /// \short du/dt at local node n. 
 /// Uses suitably interpolated value for hanging nodes.
 double du_dt(const unsigned &n) const
  {
   // Get the data's timestepper
   TimeStepper* time_stepper_pt=node_pt(n)->time_stepper_pt();

   // Number of timsteps (past & present)
   unsigned n_time = time_stepper_pt->ntstorage();

   //Initialise dudt
   double dudt=0.0;
   //Loop over the timesteps, if there is a non Steady timestepper
   if (time_stepper_pt->type()!="Steady")
    {
     for(unsigned t=0;t<n_time;t++)
      {
       dudt+=time_stepper_pt->weight(1,t)*u(t,n);
      }
    }
   return dudt;
  }


 /// Output with default number of plot points
 void output(std::ostream &outfile) 
  {
   unsigned nplot=5;
   output(outfile,nplot);
  }


 /// \short Output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &nplot);

 /// C_style output with default number of plot points
 void output(FILE* file_pt)
  {
   unsigned n_plot=5;
   output(file_pt,n_plot);
  }


 /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at 
 /// n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot);


 /// Output exact soln: x,y,u_exact or x,y,z,u_exact at nplot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &nplot, 
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt);


 /// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at 
 /// nplot^DIM plot points (time-dependent version)
 virtual 
  void output_fct(std::ostream &outfile, const unsigned &nplot,
                  const double& time, 
                  FiniteElement::UnsteadyExactSolutionFctPt 
                  exact_soln_pt);


 /// Get error against and norm of exact solution
 void compute_error(std::ostream &outfile, 
                    FiniteElement::SteadyExactSolutionFctPt 
                    exact_soln_pt,
                    double& error, double& norm);


 /// Get error against and norm of exact solution
 void compute_error(std::ostream &outfile, 
                    FiniteElement::UnsteadyExactSolutionFctPt 
                    exact_soln_pt,
                    const double& time, double& error, double& norm);


 /// Access function: Pointer to source function
 FisherSourceFctPt& source_fct_pt() {return Source_fct_pt;}


 /// Access function: Pointer to source function. Const version
 FisherSourceFctPt source_fct_pt() const {return Source_fct_pt;}


 /// \short Get source term at continous time t and (Eulerian) position x.
 /// Virtual so it can be overloaded in derived multiphysics elements. 
 inline void get_source(const double& t, 
                        const Vector<double>& x,
                        double& source) const
  {
   //If no source function has been set, return zero
   if(Source_fct_pt==0) {source = 0.0;}
   else
    {
     // Get source strength
     (*Source_fct_pt)(t,x,source);
    }
  }

 /// Get flux: flux[i] = du/dx_i
 void get_flux(const Vector<double>& s, Vector<double>& flux) const
  {
   //Find out how many nodes there are in the element
   unsigned n_node = nnode();

   //Set up memory for the shape and test functions
   Shape psi(n_node);
   DShape dpsidx(n_node,DIM);
 
   //Call the derivatives of the shape and test functions
   dshape_eulerian(s,psi,dpsidx);
     
   //Initialise to zero
   for(unsigned j=0;j<DIM;j++) {flux[j] = 0.0;}
   
   // Loop over nodes
   for(unsigned l=0;l<n_node;l++) 
    {
     //Loop over derivative directions
     for(unsigned j=0;j<DIM;j++)
      {                               
       flux[j] += u(l)*dpsidx(l,j);
      }
    }
  }


 /// Compute element residual Vector (wrapper)
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Create a dummy matrix
   DenseMatrix<double> dummy(1);

   //Call the generic residuals function with flag set to 0
   fill_in_generic_residual_contribution(residuals,dummy,0);
  }


 /// Compute element residual Vector and element Jacobian matrix (wrapper)
 virtual void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                           DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution(residuals,jacobian,1);
  }
 

 /// Return FE representation of function value u(s) at local coordinate s
 inline double interpolated_u(const Vector<double> &s) const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Local shape function
   Shape psi(n_node);

   //Find values of shape function
   shape(s,psi);

   //Initialise value of u
   double interpolated_u = 0.0;

   //Loop over the local nodes and sum
   for(unsigned l=0;l<n_node;l++) 
    {
     interpolated_u+=u(l)*psi[l];
    }

   return(interpolated_u);
  }

 /// \short Self-test: Return 0 for OK
 unsigned self_test();


protected:

 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// local coord. s; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian(const Vector<double> &s, Shape &psi, 
                                          DShape &dpsidx, Shape &test, 
                                          DShape &dtestdx) const=0;


 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 virtual double dshape_and_dtest_eulerian_at_knot(const unsigned &ipt, 
                                                  Shape &psi, 
                                                  DShape &dpsidx,
                                                  Shape &test, 
                                                  DShape &dtestdx)
  const=0;

 /// \short Compute element residual Vector only (if flag=and/or element 
 /// Jacobian matrix 
 virtual void fill_in_generic_residual_contribution(Vector<double> &residuals, 
                                                DenseMatrix<double> &jacobian, 
                                                unsigned flag); 

 /// Pointer to source function:
 FisherSourceFctPt Source_fct_pt;
 

 /// \short Get the local equation number of the (one and only) unknown
 /// stored at local node n (returns -1 if value is pinned).
 /// Can be overloaded in derived multiphysics elements.
 virtual inline int u_local_eqn(const unsigned &n) 
  {return nodal_local_eqn(n,0);}


  private:

 //Pointer to Fisher factor
 double* Fisher_factor_pt;

 /// Static default value for Fisher factor
 static double Default_Fisher_Factor_Value;

};






///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//======================================================================
/// QFisherElement elements are linear/quadrilateral/brick-shaped 
/// Fisher elements with isoparametric interpolation for the function.
///
/// Empty, just establishes the template parameters
///
///
//======================================================================
template <unsigned DIM, unsigned NNODE_1D>
class QFisherElement
{

private:

 // Note: this is just in here to stop doxygen from barking.
 // This is a policy class and we provide specialised versions
 // for all dimensions below, so this one never actually gets built

 /// \short Static array of ints to hold number of variables at 
 /// nodes: Initial_Nvalue[n]
 static const unsigned Initial_Nvalue[];
 
};





///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//======================================================================
/// QFisherElement<1,NNODE_1D> elements are 1D Fisher elements 
/// with  NNODE_1D nodal points in each coordinate direction. Inherits
/// from QElement and FisherEquations.
//======================================================================
template <unsigned NNODE_1D>
class QFisherElement<1,NNODE_1D> : public virtual QElement<1,NNODE_1D>, 
 public FisherEquations<1>
{
 
  public:

 ///\short  Constructor: Call constructors for QElement and 
 /// Fisher equations
 QFisherElement() : QElement<1,NNODE_1D>(), FisherEquations<1>()
  { }

 /// Broken copy constructor
 QFisherElement(const QFisherElement& dummy) 
  { 
   BrokenCopy::broken_copy("QFisherElement");
  } 
 
 /// Broken assignment operator
 void operator=(const QFisherElement&) 
  {
   BrokenCopy::broken_assign("QFisherElement");
  }

 /// \short  Required  # of `values' (pinned or dofs) 
 /// at node n
 inline unsigned required_nvalue(const unsigned &n) const 
  {return Initial_Nvalue[n];}

 /// \short Output function:  
 ///  x,y,u   or    x,y,z,u
 void output(std::ostream &outfile)
  {FisherEquations<1>::output(outfile);}


 ///  \short Output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot)
  {FisherEquations<1>::output(outfile,n_plot);}


 /// \short C-style output function:  
 ///  x,y,u   or    x,y,z,u
 void output(FILE* file_pt)
  {
   FisherEquations<1>::output(file_pt);
  }


 ///  \short C-style output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot)
  {
   FisherEquations<1>::output(file_pt,n_plot);
  }


 /// \short Output function for an exact solution:
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt)
  {
   FisherEquations<1>::output_fct(outfile,n_plot,exact_soln_pt);
  }



 /// \short Output function for a time-dependent exact solution.
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 /// (Calls the steady version)
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 const double& time,
                 FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {
   FisherEquations<1>::output_fct(outfile,n_plot,time,exact_soln_pt);
  }



protected:

 /// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
 inline double dshape_and_dtest_eulerian(const Vector<double> &s, Shape &psi, 
                                         DShape &dpsidx, 
                                         Shape &test, DShape &dtestdx) const;


 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 inline double dshape_and_dtest_eulerian_at_knot(const unsigned &ipt, 
                                                 Shape &psi, 
                                                 DShape &dpsidx,
                                                 Shape &test, 
                                                 DShape &dtestdx)
  const;
 
private:

 /// \short Static array of ints to hold number of variables
 /// at nodes: Initial_Nvalue[n]
 static const unsigned Initial_Nvalue[];
 

};




//Inline functions:


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double QFisherElement<1,NNODE_1D>::
 dshape_and_dtest_eulerian(const Vector<double> &s,
                           Shape &psi, 
                           DShape &dpsidx,
                           Shape &test, 
                           DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 double J = this->dshape_eulerian(s,psi,dpsidx);
 
 //Loop over the test functions and derivatives and set them equal to the
 //shape functions
 for(unsigned i=0;i<NNODE_1D;i++)
  {
   test[i] = psi[i]; 
   dtestdx(i,0) = dpsidx(i,0);
  }
 
 //Return the jacobian
 return J;
}


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double QFisherElement<1,NNODE_1D>::dshape_and_dtest_eulerian_at_knot(
 const unsigned &ipt,
 Shape &psi, 
 DShape &dpsidx,
 Shape &test, 
 DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

 //Set the test function equation to the shape functions 
 //(Resets internal pointers)
 test = psi;
 dtestdx = dpsidx;

 //Return the jacobian
 return J;
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//======================================================================
/// QFisherElement<2,NNODE_1D> elements are quadrilateral 
/// 2D Fisher elements with 
/// NNODE_1D nodal points in each coordinate direction. Inherits
/// from QElement and FisherEquations.
///
//======================================================================
template <unsigned NNODE_1D>
class QFisherElement<2,NNODE_1D> : public virtual QElement<2,NNODE_1D>, 
 public FisherEquations<2>
{
 
  public:

 ///\short  Constructor: Call constructors for QElement and 
 /// Fisher equations
 QFisherElement() : QElement<2,NNODE_1D>(), FisherEquations<2>()
  {}

 /// Broken copy constructor
 QFisherElement(const QFisherElement& dummy) 
  { 
   BrokenCopy::broken_copy("QFisherElement");
  } 
 
 /// Broken assignment operator
 void operator=(const QFisherElement&) 
  {
   BrokenCopy::broken_assign("QFisherElement");
  }

 /// \short  Required  # of `values' (pinned or dofs) 
 /// at node n
 inline unsigned required_nvalue(const unsigned &n) const 
  {return Initial_Nvalue[n];}

 /// \short Output function:  
 ///  x,y,u   or    x,y,z,u
 void output(std::ostream &outfile)
  {FisherEquations<2>::output(outfile);}


 ///  \short Output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot)
  {FisherEquations<2>::output(outfile,n_plot);}


 /// \short C-style output function:  
 ///  x,y,u   or    x,y,z,u
 void output(FILE* file_pt)
  {
   FisherEquations<2>::output(file_pt);
  }


 ///  \short C-style output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot)
  {
   FisherEquations<2>::output(file_pt,n_plot);
  }


 /// \short Output function for an exact solution:
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt)
  {
   FisherEquations<2>::output_fct(outfile,n_plot,exact_soln_pt);
  }



 /// \short Output function for a time-dependent exact solution.
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points.
 //  (Calls the steady version)
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 const double& time,
                 FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {
   FisherEquations<2>::output_fct(outfile,n_plot,time,exact_soln_pt);
  }


protected:

/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
 inline double dshape_and_dtest_eulerian(const Vector<double> &s,
                                         Shape &psi, 
                                         DShape &dpsidx, 
                                         Shape &test, 
                                         DShape &dtestdx) const;



 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 inline double dshape_and_dtest_eulerian_at_knot(const unsigned &ipt, 
                                                 Shape &psi, 
                                                 DShape &dpsidx,
                                                 Shape &test, 
                                                 DShape &dtestdx)
  const;
 
private:

 /// \short Static array of ints to hold number of variables 
 /// at nodes: Initial_Nvalue[n]
 static const unsigned Initial_Nvalue[];
 

};




//Inline functions:


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double QFisherElement<2,NNODE_1D>::
 dshape_and_dtest_eulerian(const Vector<double> &s,
                           Shape &psi, 
                           DShape &dpsidx,
                           Shape &test, 
                           DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 double J = this->dshape_eulerian(s,psi,dpsidx);

 //Loop over the test functions and derivatives and set them equal to the
 //shape functions
 for(unsigned i=0;i<NNODE_1D*NNODE_1D;i++)
  {
   test[i] = psi[i]; 
   dtestdx(i,0) = dpsidx(i,0);
   dtestdx(i,1) = dpsidx(i,1);
  }

 //Return the jacobian
 return J;
}


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double QFisherElement<2,NNODE_1D>::dshape_and_dtest_eulerian_at_knot(
 const unsigned &ipt,
 Shape &psi, 
 DShape &dpsidx,
 Shape &test, 
 DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

 //Set the test functions equal to the shape functions
 //(Sets internal pointers)
 test = psi;
 dtestdx = dpsidx;

 //Return the jacobian
 return J;
}




/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////




//======================================================================
/// QFisherElement<3,NNODE_1D> elements are cubic 3D Fisher 
/// elements with  NNODE_1D nodal points in each coordinate direction. Inherits
/// from QElement and FisherEquations
///
//======================================================================
template <unsigned NNODE_1D>
class QFisherElement<3,NNODE_1D> : public virtual QElement<3,NNODE_1D>, 
 public FisherEquations<3>
{
 
  public:

 ///\short  Constructor: Call constructors for QElement and 
 /// Fisher equations
 QFisherElement() : QElement<3,NNODE_1D>(), FisherEquations<3>()
  {}


 /// Broken copy constructor
 QFisherElement(const QFisherElement& dummy) 
  { 
   BrokenCopy::broken_copy("QFisherElement");
  } 
 
 /// Broken assignment operator
 void operator=(const QFisherElement&) 
  {
   BrokenCopy::broken_assign("QFisherElement");
  }


 /// \short  Access function for Initial_Nvalue: # of `values' 
 /// (pinned or dofs) at node n
 inline unsigned required_nvalue(const unsigned &n) const 
  {return Initial_Nvalue[n];}


 /// \short Output function:  
 ///  x,y,u   or    x,y,z,u
 void output(std::ostream &outfile)
  {FisherEquations<3>::output(outfile);}

 ///  \short Output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(std::ostream &outfile, const unsigned &n_plot)
  {FisherEquations<3>::output(outfile,n_plot);}


 /// \short C-style output function:  
 ///  x,y,u   or    x,y,z,u
 void output(FILE* file_pt)
  {
   FisherEquations<3>::output(file_pt);
  }


 ///  \short C-style output function:  
 ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
 void output(FILE* file_pt, const unsigned &n_plot)
  {
   FisherEquations<3>::output(file_pt,n_plot);
  }


 /// \short Output function for an exact solution:
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt)
  {
   FisherEquations<3>::output_fct(outfile,n_plot,exact_soln_pt);
  }


 /// \short Output function for a time-dependent exact solution.
 ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
 /// (Calls the steady version)
 void output_fct(std::ostream &outfile, const unsigned &n_plot,
                 const double& time,
                 FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
  {
   FisherEquations<3>::output_fct(outfile,n_plot,time,exact_soln_pt);
  }


protected:

/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
 inline double dshape_and_dtest_eulerian(const Vector<double> &s, Shape &psi, 
                                         DShape &dpsidx, 
                                         Shape &test, DShape &dtestdx) const;


 /// \short Shape/test functions and derivs w.r.t. to global coords at 
 /// integration point ipt; return  Jacobian of mapping
 inline double dshape_and_dtest_eulerian_at_knot(const unsigned &ipt, 
                                                 Shape &psi, 
                                                 DShape &dpsidx,
                                                 Shape &test, 
                                                 DShape &dtestdx)
  const;

private:

 /// \short Static array of ints to hold number of variables at 
 /// nodes: Initial_Nvalue[n]
 static const unsigned Initial_Nvalue[];
 

};




//Inline functions:


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double QFisherElement<3,NNODE_1D>::
 dshape_and_dtest_eulerian(const Vector<double> &s,
                           Shape &psi, 
                           DShape &dpsidx, 
                           Shape &test, 
                           DShape &dtestdx) const
{

 //Call the geometrical shape functions and derivatives  
 double J = this->dshape_eulerian(s,psi,dpsidx);

 //Loop over the test functions and derivatives and set them equal to the
 //shape functions
 for(unsigned i=0;i<NNODE_1D*NNODE_1D*NNODE_1D;i++)
  {
   test[i] = psi[i]; 
   dtestdx(i,0) = dpsidx(i,0);
   dtestdx(i,1) = dpsidx(i,1);
   dtestdx(i,2) = dpsidx(i,2);
  }

 //Return the jacobian
 return J;
}


//======================================================================
/// Define the shape functions and test functions and derivatives
/// w.r.t. global coordinates and return Jacobian of mapping.
///
/// Galerkin: Test functions = shape functions
//======================================================================
template<unsigned NNODE_1D>
double QFisherElement<3,NNODE_1D>::dshape_and_dtest_eulerian_at_knot(
 const unsigned &ipt,
 Shape &psi, 
 DShape &dpsidx,
 Shape &test, 
 DShape &dtestdx) const
{
 //Call the geometrical shape functions and derivatives  
 double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

 //Set the test function equation to the shape functions 
 //(Resets internal pointers)
 test = psi;
 dtestdx = dpsidx;

 //Return the jacobian
 return J;
}


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//=======================================================================
/// Face geometry for the QFisherElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<QFisherElement<DIM,NNODE_1D> >: 
 public virtual QElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

};

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 1D QFisherElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<QFisherElement<1,NNODE_1D> >: 
 public virtual PointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : PointElement() {}

};


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


}


#endif
