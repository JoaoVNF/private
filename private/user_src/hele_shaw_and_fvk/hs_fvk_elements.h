//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented,
//LIC// multi-physics finite-element library, available
//LIC// at http://www.oomph-lib.org.
//LIC//
//LIC//           Version 0.90. August 3, 2009.
//LIC//
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC//
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC//
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC//
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC//
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC//
//LIC//====================================================================
//Header file for HeleShaw elements
#ifndef OOMPH_HELE_SHAW_FOEPPL_VON_KARMAN_ELEMENTS_HEADER
#define OOMPH_HELE_SHAW_FOEPPL_VON_KARMAN_ELEMENTS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include "foeppl_von_karman.h"
#include "Thele_shaw_elements.h"

namespace oomph
{


namespace Junk
{ 
 bool Do_junk_string=false;
 std::string Junk_string;
}


//==============================================================
/// Combined triangular Hele Shaw and Foeppl von Karman elements
/// for elastic-walled Hele Shaw problem
//==============================================================
template<unsigned NNODE_1D>
class THeleShawFoepplvonKarmanElement
 : public virtual TFoepplvonKarmanElement<NNODE_1D>,
   public virtual THeleShawElement<NNODE_1D>
{

public:

 /// Constructor
 THeleShawFoepplvonKarmanElement() : TFoepplvonKarmanElement<NNODE_1D>(),
  THeleShawElement<NNODE_1D>()
   {
    Q_pt = &Default_Physical_Constant_Value;
    Aspect_ratio_pt=0;
   }
  

  /// Access to FSI parameter Q
  const double &q() const {return *Q_pt;}
  
  /// Pointer to FSI parameter Q
  double* &q_pt() {return Q_pt;}
  

  /// \short Overloaded function to return the "bubble volume".
  /// Overloads function in FvK elements and incorporates aspect
  /// ratio and offset.
  virtual double get_bounded_volume() const
  {
   //Number of nodes and integration points for the current element
   const unsigned n_node = this->nnode();
   const unsigned n_intpt = this->integral_pt()->nweight();
   
   //Shape functions and their derivatives
   Shape psi(n_node);
   DShape dpsidx(n_node,2);
   
   //The nodal index at which the displacement is stored
   const unsigned w_nodal_index = this->nodal_index_fvk();
   
   //Initalise the integral
   double integral = 0;
   
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Get the integral weight
     double w = this->integral_pt()->weight(ipt);
     
     //Get determinant of the Jacobian of the mapping
     double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);
     
     //Premultiply the weight and Jacobian
     double W = w*J;
     
     //Initialise storage for the w value and nodal value
     double interpolated_w = 0;
     double w_nodal_value;
     
     //Loop over the shape functions/nodes
     for(unsigned l=0;l<n_node;l++)
      {
       //Get the current nodal value
       w_nodal_value = this->raw_nodal_value(l,w_nodal_index);

       //Add the contribution to interpolated w
       interpolated_w += w_nodal_value*psi(l);
      }
     
     //Add the contribution from the current integration point
     integral += (1.0+interpolated_w/aspect_ratio())*W;
    }
   return integral;
  }
  
  
  // hierher kill next time
 /*  /// \short  Compute the volume "bounded by the element" (same as  */
 /*  /// what is returned by get_bounded_volume()) and fill in the element's */
 /*  /// contribution to the derivative of the bounded volume w.r.t. to the */
 /*  /// element's unknowns (enumerated by global (!) eqn number). */
 /*  /// Overloaded from version in base class to include offset and  */
 /*  /// aspect ratio */
 /*  virtual void fill_in_d_bounded_volume_d_unknown( */
 /*   double& el_bounded_volume, */
 /*   std::map<unsigned,double>& dv_du) const */
 /*  { */
 /*   //Number of nodes and integration points for the current element */
 /*   const unsigned n_node = this->nnode(); */
 /*   const unsigned n_intpt = this->integral_pt()->nweight(); */
   
 /*   //Shape functions  */
 /*   Shape psi(n_node); */
   
 /*   // Deriv of Jacobian of mapping between local and Eulerian coords */
 /*   // w.r.t. nodal coords */
 /*   DenseMatrix<double> dJ_dX(2,n_node); */
   
 /*   //The nodal index at which the displacement is stored */
 /*   const unsigned w_nodal_index = nodal_index_fvk(); */
   
 /*   // Initialise  */
 /*   el_bounded_volume=0.0;  */
   
 /*   //Loop over the integration points */
 /*   for(unsigned ipt=0;ipt<n_intpt;ipt++) */
 /*    { */
 /*     //Get the integral weight */
 /*     double w = this->integral_pt()->weight(ipt); */
     
 /*     //Get determinant of the Jacobian of the mapping */
 /*     double J = this->dJ_eulerian_at_knot(ipt,psi,dJ_dX); */
     
 /*     //Premultiply the weight and Jacobian */
 /*     double W = w*J; */

 /*     // Add to volume: Constant thickness term */
 /*     el_bounded_volume+=W; */
     
 /*     //Loop over the shape fcts/nodes */
 /*     for(unsigned l=0;l<n_node;l++) */
 /*      { */
 /*       // Get node */
 /*       Node* nod_pt=this->node_pt(l); */
       
 /*       // Get nodal displacement */
 /*       double w_nodal_value = this->raw_nodal_value(l,w_nodal_index); */
       
 /*       // Add to volume: displacement term */
 /*       el_bounded_volume+=w_nodal_value*psi(l)/aspect_ratio()*W; */
       
 /*       //Get the global equation number */
 /*       int eqn_number = nod_pt->eqn_number(w_nodal_index); */
       
 /*      // Add contribution: Deriv of volume w.r.t. nodal displacement */
 /*      if (eqn_number>=0) */
 /*       { */
 /*        dv_du[eqn_number]+=psi(l)/aspect_ratio()*W; */
 /*       }       */
    
 /*      //Loop over nodes for derivs. w.r.t. to nodal positions */
 /*      for(unsigned ll=0;ll<n_node;ll++) */
 /*       { */
 /*        // Get node */
 /*        Node* nnod_pt=this->node_pt(ll); */
        
 /*        // Loop over nodal positions if nodes are SolidNodes */
 /*        SolidNode *solid_node_pt = dynamic_cast<SolidNode*>(nnod_pt); */
 /*        if (solid_node_pt != 0) */
 /*         { */
 /*          Data* data_pt=solid_node_pt->variable_position_pt(); */
          
 /*          // Loop over values (directions) */
 /*          unsigned nval=data_pt->nvalue(); */
 /*          for (unsigned i=0;i<nval;i++) */
 /*           { */
            
 /*            //Get the global equation number */
 /*            int eqn_number = data_pt->eqn_number(i); */
            
 /*            // Add contribution to deriv. of volume w.r.t. to nodal position */
 /*            // (via Jacobian of mapping) */
 /*            if (eqn_number>=0) */
 /*             { */
 /*              dv_du[eqn_number]+= */
 /*               (1.0/double(n_node)+w_nodal_value*psi(l)/aspect_ratio())* */
 /*               w*dJ_dX(i,ll); */
 /*             } */
 /*           }     */
 /*         } */
 /*       } */
 /*     } */
 /*   } */
 /* } */



  /// \short Output all quantities at Gauss points
  void output_at_gauss_points(std::ostream &outfile) const
   {
    // Find out how many nodes there are
    const unsigned n_node = this->nnode();
    
    // Set up memory for the shape and test functions
    Shape psi(n_node), test(n_node);
    DShape dpsidx(n_node,2), dtestdx(n_node,2);
    
    // Index at which the hele_shaw unknown is stored
    //const unsigned p_nodal_index = p_index_hele_shaw();

    // Vector of local coordinates and velocity
    Vector<double> s(2);
    Vector<double> velocity(2);
    
    // Loop over integration points
    const unsigned n_intpt = this->integral_pt()->nweight();

    //Loop over the integration points
    for(unsigned ipt=0;ipt<n_intpt;ipt++)
     {

      // Get local coords of int point
      Vector<double> s(2);
      for(unsigned i=0;i<2;i++)
       {
        s[i] = this->integral_pt()->knot(ipt,i);
       }
      
      // Get velocity
      this->get_velocity(s,velocity);

      // Get coords
      Vector<double> x(2);
      for(unsigned i=0;i<2;i++)
       {
        x[i]=this->interpolated_x(s,i);
       }

      // Get pressure
      double pressure=0.0;
      get_pressure_fvk(ipt,x,pressure);
      

      // Call the derivatives of the shape and test functions
      //double J = 
      this->dshape_and_dtest_eulerian_at_knot_hele_shaw(
       ipt,psi,dpsidx,
       test,dtestdx);
      
      
      // Calculate local values of unknown
      // Allocate and initialise to zero
      Vector<double> interpolated_x(2,0.0);
      Vector<double> interpolated_dpdx(2,0.0);
      
      // Loop over nodes
      for(unsigned l=0; l<n_node; l++)
       {
        // Loop over directions
        for(unsigned j=0; j<2; j++)
         {
          interpolated_x[j] += this->raw_nodal_position(l,j)*psi(l);
         }
       }
      

      // Get gap width and (Eulerian!) wall velocity
      // (Pass in psi and dpsidx to avoid their recomputation
      // in fsi context)
      double h = 1.0;
      double dhdt = 0.0;
      Junk::Do_junk_string=true;
      get_upper_wall_data(s,interpolated_x,psi,dpsidx,h,dhdt);
      Junk::Do_junk_string=false;

      // Output
      for(unsigned i=0;i<2;i++)
       {
        outfile << x[i] << " ";
       }
      outfile << velocity[0] << " "
              << velocity[1] << " "
              << pressure << " "
              << this->interpolated_w_fvk(s) << " "
              << h << " " 
              << dhdt << " " 
              << Junk::Junk_string
              << "\n";
     }
   }

  /// \short Overloaded version of function that determines the pressure
  /// on the elastic membrane at Gauss point ipt, with spatial
  /// coordinate x.
  inline virtual void get_pressure_fvk(const unsigned& ipt,
                                       const Vector<double>& x,
                                       double& pressure) const
   {
    // Get contribution from Foeppl von Karmann -- essentially
    // the external pressure
    double pressure_fvk=0.0;
    FoepplvonKarmanEquations::get_pressure_fvk(ipt,x,pressure_fvk);
    
    // Which nodal value represents the Hele Shaw pressure?
    unsigned p_nodal_index = this->p_index_hele_shaw();

    // Hele Shaw pressure
    double pressure_hs = 0.0;

    // We're in the bubble, so get the pressure from the external data    
    if(this->Hele_shaw_disabled)
     {
      if (this->nexternal_data()!=0)
       {
        pressure_hs = this->external_data_pt(0)->value(0);
       }
      else
       {
        pressure_hs=0.0;
       }
     }
    // We're outside the bubble, so get the pressure from Hele-Shaw
    else 
     {
      //Set up memory for the shape and test functions
      const unsigned n_node = this->nnode();
      Shape psi(n_node);      
      Vector<double> s(2);
      for(unsigned i=0;i<2;i++)
       {
        s[i] = this->integral_pt()->knot(ipt,i);
       }
      
      this->shape(s,psi);
      
      //Initialise storage for the w value and nodal value
      double p_nodal_value = 0;
      
      for(unsigned l=0;l<n_node;l++)
       {
        //Get the current nodal value
        p_nodal_value = this->raw_nodal_value(l,p_nodal_index);
        //Add the contribution to interpolated p
        pressure_hs += p_nodal_value*psi(l);
       }
     }
    
    // Return the sum of the single-physics FvK pressure and the multi-physics
    // Hele-Shaw pressure, weighted by the FSI parameter, q
    pressure = pressure_fvk + this->q()*pressure_hs;
   }


  /// \short Get wall shape of the deformable "upper wall" of the Hele Shaw
  /// cell from Foeppl von Karman.
  /// Shape function and its deriv. w.r.t. to global coordinate
  /// is passed in for efficiency to allow computation
  /// of mesh velocity without having to recompute it.
  inline virtual void get_upper_wall_data(const Vector<double>& s,
                                          const Vector<double>& x,
                                          const Shape& psi,
                                          const DShape& dpsidx,
                                          double& b,
                                          double& dbdt) const
   {
    //Find number of nodes
    const unsigned n_node = this->nnode();
    
    //Get the index at which the vertical displacement is stored
    const unsigned w_nodal_index = this->nodal_index_fvk();
    

    //Get the index at which the smoothed x-deriv of displacement is stored
    const unsigned smooth_dwdx_nodal_index = this->nodal_index_fvk(4);
    const unsigned smooth_dwdy_nodal_index = this->nodal_index_fvk(5);
    
    // Mesh velocity
    Vector<double> mesh_velocity(2,0.0);

    // Gradient of wall displacement
    Vector<double> dwdx(2,0.0);
    
    //Initialise value of w and dw/dt
    double w = 0.0;
    double w_prev=0.0;
    double dwdt = 0.0;
    
    //Loop over the local nodes and sum
    for(unsigned l=0;l<n_node;l++)
     {
      // Build up fvk wall displacement
      w += this->nodal_value(l,w_nodal_index)*psi[l];
      w_prev += this->nodal_value(1,l,w_nodal_index)*psi[l];

      // Get the data's timestepper
      TimeStepper* time_stepper_pt = this->node_pt(l)->time_stepper_pt();
      
      // Number of timsteps (past & present)
      const unsigned n_time = time_stepper_pt->ntstorage();
      
      //Add the contributions to the time derivative
      for(unsigned t=0;t<n_time;t++)
       {
        dwdt += time_stepper_pt->weight(1,t)*
         this->nodal_value(t,l,w_nodal_index)*psi[l];
       }
     }
    
    // Mesh velocity and gradient
    double ale_bit=0.0;
    for(unsigned l=0;l<n_node;l++)
     {
      for(unsigned j=0;j<2;j++)
       {
        mesh_velocity[j] += this->raw_dnodal_position_dt(l,j)*psi(l);
        //dwdx[j] += this->nodal_value(l,w_nodal_index)*dpsidx(l,j);
       }
      dwdx[0] += this->nodal_value(l,smooth_dwdx_nodal_index)*psi(l);
      dwdx[1] += this->nodal_value(l,smooth_dwdy_nodal_index)*psi(l);
     }
    ale_bit=mesh_velocity[0]*dwdx[0]+mesh_velocity[1]*dwdx[1];
    

    if (Junk::Do_junk_string)
     {
      std::stringstream junk;
      junk << dwdt << " " << ale_bit << " " << dwdt-ale_bit  << " " 
           << mesh_velocity[0] << " " << dwdx[0] << " " 
           << mesh_velocity[1] << " " << dwdx[1] << " "
           << w_prev << " ";
      Junk::Junk_string=junk.str();
     }
      
    // Subtract ALE bits...
    dwdt-=ale_bit;
    
    // Rescale on Hele - Shaw transverse non-dim
    b=1.0+w/aspect_ratio(); 
    dbdt=dwdt/aspect_ratio();
   }
  
  
  
  /// Aspect ratio: Reference gap width / in-plane lengthscale
  double aspect_ratio() const
  {
#ifdef PARANOID
   if (Aspect_ratio_pt==0)
    {
     throw OomphLibError(
      "Aspect_ratio_pt not set yet for elastic-walled HeleShaw elements",
      "THeleShawFoepplvonKarmanElement::aspect_ratio()",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return *Aspect_ratio_pt;
  }
  
  /// \short Pointer to aspect ratio
  double*& aspect_ratio_pt()
   {
    return Aspect_ratio_pt;
   }    
  
  /// \short Pointer to aspect ratio. Const version.
  double* aspect_ratio_pt() const
   {
    return Aspect_ratio_pt;
   }
    
  
  /// \short Number of nodal values required at node n: sum of Hele Shaw
  /// and Foeppl von Karman ones.
  unsigned required_nvalue(const unsigned &n) const
  {
   return THeleShawElement<NNODE_1D>::required_nvalue(n)
    + TFoepplvonKarmanElement<NNODE_1D>::required_nvalue(n);
  }

  /// \short Overload function that returns index of nodal value that
  /// represents FvK wall displacement (if no argument or argument 
  /// is 0; otherwise get the auxiliary fields required in 
  /// FvK; check that element for details.
 virtual inline unsigned nodal_index_fvk(const unsigned& i=0) const {return i;}

 /// \short Overload function that returns index of nodal value that
 /// stores Hele Shaw pressure
 virtual inline unsigned p_index_hele_shaw() const {return 8;}

 /// Assemble residuals from contributions of underlying elements
 void fill_in_contribution_to_residuals(Vector<double> &residuals)
 {  
  TFoepplvonKarmanElement<NNODE_1D>::
   fill_in_contribution_to_residuals(residuals);
  THeleShawElement<NNODE_1D>::fill_in_contribution_to_residuals(residuals);
 }
 
 ///\short Compute the element's residual vector and the Jacobian matrix.
 /// Jacobian is computed by finite-differencing.
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                       DenseMatrix<double> &jacobian)
 {

  oomph_info << "hierher shouldn't really call this -- overloaded by\n"
             << "brutal global FD routine in wrapper class in driver code\n"
             << "tidy this at some point...\n";
  exit(0);

  // these are only the diagonal entries... 
  TFoepplvonKarmanElement<NNODE_1D>::
   fill_in_contribution_to_jacobian(residuals,jacobian);
  THeleShawElement<NNODE_1D>::
   fill_in_contribution_to_jacobian(residuals,jacobian);
 }
 
 ///  Overload the standard output function with the broken default
 void output(std::ostream &outfile)
 {
  this->output(outfile,3);
 }
 

 /// Output
 void output(std::ostream &outfile,
             const unsigned &nplot)
 {
  // Vector of local coordinates and velocity
  Vector<double> s(2);
  Vector<double> velocity(2);
  
  // Tecplot header info
  outfile << this->tecplot_zone_string(nplot);
  
  // Loop over plot points
  unsigned num_plot_points = this->nplot_points(nplot);
  for (unsigned iplot=0; iplot<num_plot_points; iplot++)
   {    
    // Get local coordinates and velocity at plot point
    this->get_s_plot(iplot,nplot,s);
    this->get_velocity(s,velocity);
    
    // We're in the bubble, so get the pressure from the external data    
    double pressure_hs=0.0;
    if(this->Hele_shaw_disabled)
     {
      if (this->nexternal_data()!=0)
       {
        pressure_hs = this->external_data_pt(0)->value(0);
       }
      else
       {
        pressure_hs=0.0;
       }
     }
    else
     {
      pressure_hs=this->interpolated_p_hele_shaw(s);
     }

    // output
    Vector<double> xx(2);
    for(unsigned i=0; i<2; i++)
     {
      xx[i]=this->interpolated_x(s,i);
      outfile << xx[i] << " ";
     }
    outfile << velocity[0] << " "
            << velocity[1] << " "
            << pressure_hs << " "
            << this->interpolated_w_fvk(s) << " "; //"\n";

    
    // Get gap width and (Eulerian!) wall velocity
    // (Pass in psi and dpsidx to avoid their recomputation
    // in fsi context)
    unsigned n_dim=this->dim();
    unsigned n_node=this->nnode();
    Shape psi(n_node);
    DShape dpsidx(n_node,n_dim);
    this->dshape_eulerian(s,psi,dpsidx);
    double h = 1.0;
    double dhdt = 0.0;
    get_upper_wall_data(s,xx,psi,dpsidx,h,dhdt);
    outfile << h << " " << dhdt << " ";
    
    // Get in-plane stress
    double sigma_xx=0.0;
    double sigma_yy=0.0;
    double sigma_xy=0.0;
    this->interpolated_stress(s,sigma_xx,sigma_yy,sigma_xy);
    outfile << sigma_xx << " " 
            << sigma_yy << " " 
            << sigma_xy << " ";
    
    // Convert to polars
    if ((xx[0]==0.0)&&(xx[1]==0.0))
     {
      outfile << "0.0 0.0 0.0 ";
     }
    else
     {
      double theta=atan2(xx[1],xx[0]);
      double sigma_rr=
       sigma_xx*cos(theta)*cos(theta)+
       sigma_yy*sin(theta)*sin(theta)+
       sigma_xy*sin(2.0*theta);
      
      double sigma_tt=
       sigma_xx*sin(theta)*sin(theta)+
       sigma_yy*cos(theta)*cos(theta)-
       sigma_xy*sin(2.0*theta);
      
      double sigma_rt=
       (sigma_yy-sigma_xx)*sin(theta)*cos(theta)+
       sigma_xy*cos(2.0*theta);
      
      outfile << sigma_rr << " " 
              << sigma_tt << " " 
              << sigma_rt << " "; 
     }


    outfile << std::endl;
    
   }
  
  // Write tecplot footer (e.g. FE connectivity lists)
  this->write_tecplot_zone_footer(outfile,nplot);  
 }

 
 /// \short C-style output function: Broken default
 void output(FILE* file_pt)
 {FiniteElement::output(file_pt);}
 
 ///  \short C-style output function: Broken default
 void output(FILE* file_pt, const unsigned &n_plot)
 {FiniteElement::output(file_pt,n_plot);}
 
 /// \short Output function for an exact solution: Broken default
 void output_fct(std::ostream &outfile, const unsigned &Nplot,
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact_soln_pt)
 {FiniteElement::output_fct(outfile,Nplot,exact_soln_pt);}
 
 
 /// \short Output function for a time-dependent exact solution:
 /// Broken default.
 void output_fct(std::ostream &outfile, const unsigned &Nplot,
                 const double& time,
                 FiniteElement::UnsteadyExactSolutionFctPt 
                 exact_soln_pt)
 {
  FiniteElement::
   output_fct(outfile,Nplot,time,exact_soln_pt);
 }
 
 /// \short Validate against exact solution at given time
 /// Solution is provided via function pointer.
 /// Plot at a given number of plot points and compute L2 error
 /// and L2 norm of velocity solution over element
 /// Call the broken default
 void compute_error(std::ostream &outfile,
                    FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                    const double& time,
                    double& error, double& norm)
  {FiniteElement::compute_error(outfile,exact_soln_pt,
                                time,error,norm);}
 
 /// \short Validate against exact solution.
 /// Solution is provided via function pointer.
 /// Plot at a given number of plot points and compute L2 error
 /// and L2 norm of velocity solution over element
 /// Call the broken default
 void compute_error(std::ostream &outfile,
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                    double& error, double& norm)
 {FiniteElement::compute_error(outfile,exact_soln_pt,error,norm);}
 

 /// Call self tests of underlying elements
 unsigned self_test()
 {
   unsigned hs_test_result = THeleShawElement<NNODE_1D>::self_test();
   unsigned fvk_test_result = TFoepplvonKarmanElement<NNODE_1D>::self_test();

   if (hs_test_result == 0 && fvk_test_result == 0)
    {
     return 0;
    }
   else
    {
     return 1;
    }
  }


 /// \short Pin all Foeppl von Karmann dofs -- turns problem into
 /// single physics Hele Shaw problem
 void pin_fvk()
 {
  unsigned n_node = this->nnode();
  for(unsigned i_node = 0; i_node < n_node; i_node++)
   {
    Node *nod_pt = this->node_pt(i_node);
    for(unsigned index = 0;index < 8; index++)
     {
      nod_pt->pin(index);
     }
   }
 }
 
 
 /// \short Pin all Hele Shaw dofs -- turns problem into single
 /// physics Foeppl von Karmann problem
 void pin_hs()
 {
  unsigned n_node = this->nnode();
  for(unsigned i_node = 0; i_node < n_node; i_node++)
   {
    Node *nod_pt = this->node_pt(i_node);
    unsigned n_value = nod_pt->nvalue();
    for(unsigned index = 8; index < n_value; index++)
     {
      nod_pt->pin(index);
     }
   }
 }
 
  protected:
 
 /// Pointer to FSI parameter Q
 double *Q_pt;
 
 /// \short Order of recovery shape functions for Z2 error estimation:
 /// Same order as shape functions.
 unsigned nrecovery_order() {return (NNODE_1D-1);}
 
 /// \short Number of 'flux' terms for Z2 error estimation -- currently
 /// based on Hele Shaw
 unsigned num_Z2_flux_terms()
 {
  return THeleShawElement<NNODE_1D>::num_Z2_flux_terms();
 }
 
 /// Get 'flux' for Z2 error recovery -- currently based on Hele Shaw
 void get_Z2_flux(const Vector<double>& s, Vector<double>& flux)
 {
  THeleShawElement<NNODE_1D>::get_Z2_flux(s, flux);
 }
 
 /// \short Number of vertex nodes in the element
 unsigned nvertex_node() const
 {return TElement<2,NNODE_1D>::nvertex_node();}
 
 /// \short Pointer to the j-th vertex node in the element
 Node* vertex_node_pt(const unsigned& j) const
  {return TElement<2,NNODE_1D>::vertex_node_pt(j);}
 
private:


 /// \short Pointer to the aspect_ratio ratio: reference gap width / 
 /// in-plane lengthscale
 double* Aspect_ratio_pt;
 
 /// Default value for physical constants
 static double Default_Physical_Constant_Value;

};



///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


//==========================================================
/// Instantiation of default value for FSI parameter
//==========================================================
template<unsigned NNODE_1D>
double THeleShawFoepplvonKarmanElement<NNODE_1D>::
Default_Physical_Constant_Value = 0.0;

}

#endif
